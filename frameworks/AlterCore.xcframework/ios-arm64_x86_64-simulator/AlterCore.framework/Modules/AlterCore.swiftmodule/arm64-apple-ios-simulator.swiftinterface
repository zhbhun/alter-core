// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target arm64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name AlterCore
import AVFoundation
import AVKit

import CoreGraphics
import CoreMedia
import CoreVideo
import Foundation
import Metal
import MetalKit
import Photos
import QuartzCore
import Swift
import UIKit
import VideoToolbox
import _Concurrency
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class AvatarView : AlterCore.BasicRendererView, AlterCore.AvatarViewInterface {
  @_Concurrency.MainActor(unsafe) public var _wrappedAvatarViewInterface: Swift.AnyObject {
    get
  }
  @_Concurrency.MainActor(unsafe) public var avatar: AlterCore.Avatar?
  @_Concurrency.MainActor(unsafe) public var avatarController: AlterCore.AvatarController?
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func setOnFrameListener(_ onFrame: @escaping (_ deltaTime: Swift.Float) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToWindow()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class CameraWrapper : ObjectiveC.NSObject {
  public var automaticallyAdjustOrientation: Swift.Bool
  @discardableResult
  public func start(frontFacing: Swift.Bool = true) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func addOnFrameListener(_ listener: @escaping (CoreMedia.CMSampleBuffer) -> Swift.Void)
  public func changeOrientation(_ newOrientation: UIKit.UIDeviceOrientation = UIDevice.current.orientation)
  public var imageOrientation: ImageIO.CGImagePropertyOrientation {
    get
  }
  public var frameResolution: (Swift.Int, Swift.Int) {
    get
  }
  public var paused: Swift.Bool {
    get
  }
  public func toggleFlash()
  @discardableResult
  public func pause() -> AlterCore.Future<Swift.Void>
  @discardableResult
  public func resume() -> AlterCore.Future<Swift.Void>
  @discardableResult
  public func stop() -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func switchLowLight(lowLightOn: Swift.Bool)
  @objc deinit
  @objc override dynamic public init()
}
extension AlterCore.CameraWrapper : AVFoundation.AVCaptureVideoDataOutputSampleBufferDelegate {
  @objc dynamic public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
}
extension UIKit.UIColor {
  public var rgbComponents: (red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) {
    get
  }
}
extension Swift.Int {
  public var n: Swift.Float {
    get
  }
}
extension Swift.Float {
  public var n: Swift.Float {
    get
  }
}
extension Swift.Double {
  public var n: Swift.Float {
    get
  }
}
extension AlterCore.FacemojiAPIClass {
  @discardableResult
  public func initialize(_ apiKey: Swift.String) -> AlterCore.Future<Swift.Bool>
}
public class KotlinError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  final public let exception: AlterCore.KotlinException
  public init(_ exception: AlterCore.KotlinException)
  public var errorDescription: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension AlterCore.Try {
  public func rethrow() throws -> T
}
extension AlterCore.AvatarRenderer {
  public func fixedZReprojector() -> AlterCore.FaceTrackerReprojector
}
extension AlterCore.TrackerAvatarController {
  @discardableResult
  public func updateFromCamera(_ sampleBuffer: CoreMedia.CMSampleBuffer) -> AlterCore.FaceTrackerResult?
  @discardableResult
  public func updateFromCamera(_ buffer: CoreVideo.CVPixelBuffer) -> AlterCore.FaceTrackerResult?
  public static func create(_ avatar: AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) public class MetalTextureView : MetalKit.MTKView {
  public enum Rotation : Swift.Int {
    case rotate0Degrees
    case rotate90Degrees
    case rotate180Degrees
    case rotate270Degrees
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) public var mirrorHorizontally: Swift.Bool {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public var imageFill: AlterCore.FillMode
  @_Concurrency.MainActor(unsafe) public var pixelBuffer: CoreVideo.CVPixelBuffer? {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public func setSampleBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
  @_Concurrency.MainActor(unsafe) public func setPixelBuffer(_ newBuffer: CoreVideo.CVPixelBuffer)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
@available(*, deprecated, message: "Renamed to BasicRendererViewDelegate")
public typealias FacemojiViewRenderDelegate = AlterCore.BasicRendererViewDelegate
public protocol BasicRendererViewDelegate : AnyObject {
  func render(_ surface: AlterCore.PlatformRenderingSurface)
}
public protocol FrameDropDelegate : AnyObject {
  func onFrameDrop(_ requestedFrameTimeMs: Swift.Double, _ renderFrameTimeMs: Swift.Double) -> Swift.Bool
}
@available(*, deprecated, message: "Renamed to BasicRendererView")
public typealias FacemojiBasicView = AlterCore.BasicRendererView
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class BasicRendererView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) weak public var renderDelegate: AlterCore.BasicRendererViewDelegate? {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) weak public var frameDropDelegate: AlterCore.FrameDropDelegate?
  @_Concurrency.MainActor(unsafe) public var preferredFramesPerSecond: Swift.Float {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToSuperview()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) public var synchronizeWithUI: Swift.Bool {
    get
    set(value)
  }
  @_Concurrency.MainActor(unsafe) public func render()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) public func startRecording(recordSound: Swift.Bool = true, desiredFps: Swift.Int = 30) -> AlterCore.Try<AlterCore.ViewRecorder>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinObjectWrapper {
  @objc deinit
}
public protocol ConvertibleToKotlin {
  init(_ wrapped: AlterCore.KotlinObjectWrapper)
  func asKotlin() -> Swift.AnyObject
}
public func listOf<T>(_ items: T...) -> [T]
public func floatArrayOf(_ items: Swift.Float...) -> [Swift.Float]
public func intArrayOf(_ items: Swift.Int...) -> [Swift.Int]
public func doubleArrayOf(_ items: Swift.Double...) -> [Swift.Double]
public func floatArrayOf(_ items: Swift.Float...) -> AlterCore.KotlinFloatArray
public func intArrayOf(_ items: Swift.Int...) -> AlterCore.KotlinIntArray
public func doubleArrayOf(_ items: Swift.Double...) -> AlterCore.KotlinDoubleArray
extension Swift.Int : AlterCore.KotlinComparable {
  public typealias T = Swift.Int
  public func compareTo(_ other: Swift.Int) -> Swift.Int
}
public func assert(_ condition: Swift.Bool)
public func numArrayOf(_ elements: AlterCore.KotlinDoubleArray) -> AlterCore.KotlinFloatArray
public func numArrayOf(_ elements_: AlterCore.KotlinFloatArray) -> AlterCore.KotlinFloatArray
public func numArrayOf(_ elements__: AlterCore.KotlinIntArray) -> AlterCore.KotlinFloatArray
public func min<T>(_ a: T, _ b: T) -> T where T : AlterCore.Vec
public func max<T>(_ a: T, _ b: T) -> T where T : AlterCore.Vec
@available(*, deprecated, renamed: "FaceTrackerResultDeserializer", message: "The standalone serialization functions are not future-proof, use the FaceTrackerSerializer and FaceTrackerDeserializer objects instead, they allow exchanging the serialization format too")
public func deserializeResult(_ data: AlterCore.KotlinByteArray) -> AlterCore.DeserializedResult
extension AlterCore.File {
  public func readLines() -> AlterCore.Future<AlterCore.Try<[Swift.String]>>
}
public func imageFromBytes(_ bytes: AlterCore.KotlinByteArray) -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
public func uiImageFromBytes(_ bytes: AlterCore.KotlinByteArray) -> AlterCore.Try<AlterCore.UIKitImage>
extension AlterCore.FileSystem {
  public func subSystem(_ root: AlterCore.Path) -> AlterCore.FileSystem
}
extension AlterCore.WriteableFileSystem {
  public func subSystem(_ root_: AlterCore.Path) -> AlterCore.WriteableFileSystem
}
extension AlterCore.FileSystem {
  public func indexed(_ indexReloadIntervalMs: Swift.Int = 60 * 60 * 1000) -> AlterCore.FileSystem
}
extension AlterCore.WriteableFileSystem {
  public func indexed(_ indexReloadIntervalMs_: Swift.Int = 60 * 60 * 1000) -> AlterCore.WriteableFileSystem
}
extension AlterCore.FileSystem {
  public func textAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.String>>
}
extension AlterCore.FileSystem {
  public func watcher(_ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: AlterCore.FileWatchErrorSensitivity = .medium) -> AlterCore.FileSystemWatcher
}
public func defaultBundle() -> Foundation.Bundle
public func createDevice(_ config: AlterCore.DeviceConfig) -> AlterCore.Try<AlterCore.Device>
extension AlterCore.FileSystem {
  public func readImageList(_ images: Any) -> AlterCore.Future<AlterCore.Try<AlterCore.ImageList>>
}
extension AlterCore.FileSystem {
  public func readImageCube(_ xPos: AlterCore.Path, _ xNeg: AlterCore.Path, _ yPos: AlterCore.Path, _ yNeg: AlterCore.Path, _ zPos: AlterCore.Path, _ zNeg: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.ImageCube>>
}
public func avatarDataUrlFromKey(_ key: Swift.String, _ version: Swift.String? = nil) -> Swift.String
public func createAvatarRenderer(_ avatarRendererConfig: AlterCore.AvatarRendererConfig, _ bundledFileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
extension AlterCore.AvatarRenderer {
  public func drawUIImage(_ width: Swift.Int, _ height: Swift.Int, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false) -> AlterCore.Try<UIKit.UIImage>
}
extension AlterCore.AvatarRenderer {
  public func setBackgroundImage(_ image: CoreVideo.CVBuffer, _ fillMode: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  public func setBackgroundImage(_ image: Metal.MTLTexture, _ fillMode_: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  public func setBackgroundImage(_ image: UIKit.UIImage, _ fillMode__: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  public func setOverlayImage(_ image: CoreVideo.CVBuffer, _ fillMode: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  public func setOverlayImage(_ image: Metal.MTLTexture, _ fillMode_: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  public func setOverlayImage(_ image: UIKit.UIImage, _ fillMode__: AlterCore.FillMode)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: CoreVideo.CVBuffer)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image_: Metal.MTLTexture)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image__: UIKit.UIImage)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: CoreVideo.CVBuffer)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image_: Metal.MTLTexture)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image__: UIKit.UIImage)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: CoreVideo.CVBuffer, _ backgroundColor: AlterCore.Col)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: Metal.MTLTexture, _ backgroundColor_: AlterCore.Col)
}
extension AlterCore.AvatarRenderer {
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: UIKit.UIImage, _ backgroundColor__: AlterCore.Col)
}
public func hintGarbageCollection()
@available(*, deprecated, message: "Use only for debugging memory issues")
public func printRemainingObjects()
public func getTimeMillis() -> Swift.Int64
public var ALTER_CORE_VERSION: Swift.String {
  get
}
@available(*, deprecated, message: "Renamed to ALTER_CORE_VERSION")
public var FACEMOJI_SDK_VERSION: Swift.String {
  get
}
public var PIf: Swift.Float {
  get
}
public var PIn: Swift.Float {
  get
}
public var radianPerDegree: Swift.Float {
  get
}
public var degreePerRadian: Swift.Float {
  get
}
public var EXPRESSION_BLENDSHAPES: [Swift.String] {
  get
}
@_hasMissingDesignatedInitializers public class Camera : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var viewMatrix: AlterCore.Mat4 {
    get
  }
  public var eye: AlterCore.Vec3 {
    get
  }
  public var origin: AlterCore.Vec3 {
    get
  }
  public var view: AlterCore.Vec3 {
    get
  }
  public var orbit: Swift.Bool {
    get
  }
  public var orbitRadius: Swift.Float {
    get
  }
  public func orthoNormalized() -> AlterCore.Camera
  public func forward(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func backward(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func right(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func left(_ speed: Swift.Float = 1.n) -> AlterCore.Camera
  public func up(_ speed: Swift.Float = 1.n, _ upOverride: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func down(_ speed: Swift.Float = 1.n, _ upOverride: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func lookTo(_ viewDirection: AlterCore.Vec3, _ verticalUp: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func lookAt(_ target: AlterCore.Vec3, _ verticalUp: AlterCore.Vec3? = nil) -> AlterCore.Camera
  public func rotate(_ azimuth: Swift.Float, _ zenith: Swift.Float, _ verticalUp: AlterCore.Vec3 = Vec3.zAxis, _ zenithLimit: Swift.Float? = 0.01.n) -> AlterCore.Camera
  public func rotate(_ heading: Swift.Float, _ elevation: Swift.Float, _ bank: Swift.Float) -> AlterCore.Camera
  public func withOrigin(_ origin: AlterCore.Vec3) -> AlterCore.Camera
  public func withView(_ view: AlterCore.Vec3) -> AlterCore.Camera
  public func withUp(_ up: AlterCore.Vec3) -> AlterCore.Camera
  public func withOrbit(_ orbit: Swift.Bool) -> AlterCore.Camera
  public func withOrbitRadius(_ orbitRadius: Swift.Float) -> AlterCore.Camera
  public static func lookTo(_ origin: AlterCore.Vec3, _ viewDirection: AlterCore.Vec3, _ upDirection: AlterCore.Vec3, _ orbit: Swift.Bool = false, _ orbitRadius: Swift.Float? = nil) -> AlterCore.Camera
  public static func lookAt(_ lookFrom: AlterCore.Vec3, _ lookAt: AlterCore.Vec3, _ upDirection: AlterCore.Vec3, _ orbit: Swift.Bool = false) -> AlterCore.Camera
  public static func == (lhs: AlterCore.Camera, rhs: AlterCore.Camera) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OrbitCameraControls : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var camera: AlterCore.Camera {
    get
  }
  public func tick(_ delta: Swift.Float) -> AlterCore.OrbitCameraControls
  public static func from(_ basePosition: AlterCore.Vec3, _ targetPosition: AlterCore.Vec3, _ timeToRotate: Swift.Float, _ rotationalAxis: AlterCore.Vec3 = Vec3.zAxis) -> AlterCore.OrbitCameraControls
  public static func == (lhs: AlterCore.OrbitCameraControls, rhs: AlterCore.OrbitCameraControls) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Vec {
  typealias T = Self
  func plus(_ rhs: Self.T) -> Self
  func plus(_ rhs_: Swift.Double) -> Self
  func plus(_ rhs__: Swift.Float) -> Self
  func minus(_ rhs: Self.T) -> Self
  func minus(_ rhs_: Swift.Double) -> Self
  func minus(_ rhs__: Swift.Float) -> Self
  func times(_ rhs: Self.T) -> Self
  func times(_ rhs_: Swift.Double) -> Self
  func times(_ rhs__: Swift.Float) -> Self
  func div(_ rhs: Self.T) -> Self
  func div(_ rhs_: Swift.Double) -> Self
  func div(_ rhs__: Swift.Float) -> Self
  func unaryMinus() -> Self
  func invDiv(_ rhs: Swift.Double) -> Self
  func invDiv(_ rhs_: Swift.Float) -> Self
  func sum() -> Swift.Float
  func length() -> Swift.Float
  func lengthSquared() -> Swift.Float
  func min() -> Swift.Float
  func max() -> Swift.Float
  func dot(_ rhs: Self.T) -> Swift.Float
  func normalized() -> Self?
  func normalized(_ default: Self.T) -> Self
  func elementWise(_ rhs: Self.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  func zero() -> Self
  func one() -> Self
  func floatArray() -> AlterCore.KotlinFloatArray
}
@_hasMissingDesignatedInitializers public class VecWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Vec {
  public typealias T = AlterCore.VecWrapper
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func plus(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func times(_ rhs_: Swift.Double) -> Self
  public func times(_ rhs__: Swift.Float) -> Self
  public func div(_ rhs: AlterCore.VecWrapper.T) -> Self
  public func div(_ rhs_: Swift.Double) -> Self
  public func div(_ rhs__: Swift.Float) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length() -> Swift.Float
  public func lengthSquared() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: AlterCore.VecWrapper.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: AlterCore.VecWrapper.T) -> Self
  public func elementWise(_ rhs: AlterCore.VecWrapper.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  public func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> AlterCore.KotlinFloatArray
}
@_hasMissingDesignatedInitializers public class Vector : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible, AlterCore.Vec {
  public typealias T = AlterCore.Vector
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ elements: AlterCore.KotlinFloatArray)
  public func factory(_ elements: AlterCore.KotlinFloatArray) -> Self
  public func plus(_ rhs: AlterCore.Vector.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: AlterCore.Vector.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs: AlterCore.Vector.T) -> Self
  public func times(_ rhs_: Swift.Double) -> Self
  public func times(_ rhs__: Swift.Float) -> Self
  public func div(_ rhs: AlterCore.Vector.T) -> Self
  public func div(_ rhs_: Swift.Double) -> Self
  public func div(_ rhs__: Swift.Float) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length() -> Swift.Float
  public func lengthSquared() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: AlterCore.Vector.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: AlterCore.Vector.T) -> Self
  public func elementWise(_ rhs: AlterCore.Vector.T, _ operation: AlterCore.VecBinaryOperator) -> Self
  public func elementWise(_ operation: AlterCore.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> AlterCore.KotlinFloatArray
  public func asList() -> [Swift.Float]
  public func vecMulMat<M>(_ mat: M) -> Self where M : AlterCore.Matrix
  public static func matMulVec<M, V>(_ mat: M, _ vec: V) -> V where M : AlterCore.Matrix, V : AlterCore.Vector
  public static func == (lhs: AlterCore.Vector, rhs: AlterCore.Vector) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Col : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double, _ a: Swift.Double)
  public convenience init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double)
  public convenience init(_ r: Swift.Float, _ g: Swift.Float, _ b: Swift.Float, _ a_: Swift.Float)
  public convenience init(_ r: Swift.Float, _ g: Swift.Float, _ b_: Swift.Float)
  public convenience init(_ r: Swift.Int, _ g: Swift.Int, _ b: Swift.Int, _ a__: Swift.Int)
  public convenience init(_ r: Swift.Int, _ g: Swift.Int, _ b__: Swift.Int)
  public convenience init()
  public convenience init(_ color: Swift.Int, _ channelMap: AlterCore.KotlinIntArray = RGB)
  public var r: Swift.Float {
    get
  }
  public var g: Swift.Float {
    get
  }
  public var b: Swift.Float {
    get
  }
  public var a: Swift.Float {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var RGBA: AlterCore.KotlinIntArray {
    get
  }
  public static var BGRA: AlterCore.KotlinIntArray {
    get
  }
  public static var RGB: AlterCore.KotlinIntArray {
    get
  }
  public static var BGR: AlterCore.KotlinIntArray {
    get
  }
  public static var WHITE: AlterCore.Col {
    get
  }
  public static var BLACK: AlterCore.Col {
    get
  }
  public static var TRANSPARENT: AlterCore.Col {
    get
  }
  public static var RED: AlterCore.Col {
    get
  }
  public static var GREEN: AlterCore.Col {
    get
  }
  public static var BLUE: AlterCore.Col {
    get
  }
  public static var MAGENTA: AlterCore.Col {
    get
  }
  public static var YELLOW: AlterCore.Col {
    get
  }
  public static var CYAN: AlterCore.Col {
    get
  }
  public static var GRAY: AlterCore.Col {
    get
  }
  public func withR(_ r: Swift.Float) -> AlterCore.Col
  public func withG(_ g: Swift.Float) -> AlterCore.Col
  public func withB(_ b: Swift.Float) -> AlterCore.Col
  public func withA(_ a: Swift.Float) -> AlterCore.Col
  public func toInt(_ channelMap: AlterCore.KotlinIntArray = RGBA) -> Swift.Int
  public func clamp() -> AlterCore.Col
  public static func fromHex(_ hex: Swift.String) -> AlterCore.Try<AlterCore.Col>
  public static func == (lhs: AlterCore.Col, rhs: AlterCore.Col) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class MatrixLayout : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public var transposed: AlterCore.MatrixLayout {
    get
  }
  public static var default_: AlterCore.MatrixLayout {
    get
  }
  public func invoke(_ row: Swift.Int, _ column: Swift.Int, _ order: Swift.Int) -> Swift.Int
  public static func == (lhs: AlterCore.MatrixLayout, rhs: AlterCore.MatrixLayout) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AlterCore.MatrixLayout {
  @_hasMissingDesignatedInitializers public class RowMajorClass : AlterCore.MatrixLayout {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    override public var transposed: AlterCore.MatrixLayout {
      get
    }
    public static func == (lhs: AlterCore.MatrixLayout.RowMajorClass, rhs: AlterCore.MatrixLayout.RowMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
  public static var RowMajor: AlterCore.MatrixLayout.RowMajorClass {
    get
  }
}
extension AlterCore.MatrixLayout {
  @_hasMissingDesignatedInitializers public class ColumnMajorClass : AlterCore.MatrixLayout {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    override public var transposed: AlterCore.MatrixLayout {
      get
    }
    public static func == (lhs: AlterCore.MatrixLayout.ColumnMajorClass, rhs: AlterCore.MatrixLayout.ColumnMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
  public static var ColumnMajor: AlterCore.MatrixLayout.ColumnMajorClass {
    get
  }
}
@_hasMissingDesignatedInitializers public class Matrix : AlterCore.Vector {
  public typealias T = AlterCore.Matrix
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ elements: AlterCore.KotlinFloatArray, _ order: Swift.Int, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var order: Swift.Int {
    get
  }
  public var layout: AlterCore.MatrixLayout {
    get
  }
  public func factory(_ elements: AlterCore.KotlinFloatArray, _ order: Swift.Int, _ layout: AlterCore.MatrixLayout) -> Self
  public func transposed() -> Self
  public func transposedLayout() -> Self
  public func mul(_ rhs: AlterCore.Matrix.T) -> Self
  public func inverse() -> Self?
  public func inverse(_ default: AlterCore.Matrix.T) -> Self
  public static func == (lhs: AlterCore.Matrix, rhs: AlterCore.Matrix) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class Mat2 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: AlterCore.Vec2, _ y: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec2 {
    get
  }
  public var y: AlterCore.Vec2 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec2) -> AlterCore.Mat2
  public func withY(_ y: AlterCore.Vec2) -> AlterCore.Mat2
  public func withZ(_ z: AlterCore.Vec3) -> AlterCore.Mat3
  public func mul(_ rhs_: AlterCore.Vec2) -> AlterCore.Vec2
  public func scale() -> AlterCore.Vec2
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func scale(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func translate(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func rotate(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func rotate(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat2
  public static func == (lhs: AlterCore.Mat2, rhs: AlterCore.Mat2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Mat3 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: AlterCore.Vec3, _ y: AlterCore.Vec3, _ z: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec3 {
    get
  }
  public var y: AlterCore.Vec3 {
    get
  }
  public var z: AlterCore.Vec3 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec3) -> AlterCore.Mat3
  public func withY(_ y: AlterCore.Vec3) -> AlterCore.Mat3
  public func withZ(_ z: AlterCore.Vec3) -> AlterCore.Mat3
  public func withW(_ w: AlterCore.Vec4) -> AlterCore.Mat4
  public func mul(_ rhs_: AlterCore.Vec3) -> AlterCore.Vec3
  public func mul(_ rhs__: AlterCore.Quaternion) -> AlterCore.Mat3
  public func quaternion() -> AlterCore.Quaternion
  public func scale() -> AlterCore.Vec3
  public func scale2() -> AlterCore.Vec2
  public func translation() -> AlterCore.Vec2
  public func rotation() -> AlterCore.Quaternion
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func scale(_ vec: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ vec: AlterCore.Vec2, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func translate(_ vec: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ angle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotate(_ v1: AlterCore.Vec3, _ v2: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateX(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateX(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateY(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateY(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateZ(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func rotateZ(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public static func == (lhs: AlterCore.Mat3, rhs: AlterCore.Mat3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Mat4 : AlterCore.Matrix {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: AlterCore.Vec4, _ y: AlterCore.Vec4, _ z: AlterCore.Vec4, _ w: AlterCore.Vec4, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public convenience init(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_)
  public var x: AlterCore.Vec4 {
    get
  }
  public var y: AlterCore.Vec4 {
    get
  }
  public var z: AlterCore.Vec4 {
    get
  }
  public var w: AlterCore.Vec4 {
    get
  }
  public var mat2: AlterCore.Mat2 {
    get
  }
  public var mat3: AlterCore.Mat3 {
    get
  }
  public var mat4: AlterCore.Mat4 {
    get
  }
  public func withX(_ x: AlterCore.Vec4) -> AlterCore.Mat4
  public func withY(_ y: AlterCore.Vec4) -> AlterCore.Mat4
  public func withZ(_ z: AlterCore.Vec4) -> AlterCore.Mat4
  public func withW(_ w: AlterCore.Vec4) -> AlterCore.Mat4
  public func mul(_ rhs_: AlterCore.Vec4) -> AlterCore.Vec4
  public func mul(_ rhs__: AlterCore.Quaternion) -> AlterCore.Mat4
  public func quaternion() -> AlterCore.Quaternion
  public func scale() -> AlterCore.Vec3
  public func translation() -> AlterCore.Vec3
  public func rotation() -> AlterCore.Quaternion
  public static func identity(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ vec: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func scale(_ vec: AlterCore.Vec4, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double? = nil, _ z: Swift.Double? = nil, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float? = nil, _ z: Swift.Float? = nil, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ vec: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func translate(_ vec: AlterCore.Vec4, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angleXYZ: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ angle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: AlterCore.Vec3, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotate(_ v1: AlterCore.Vec3, _ v2: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateX(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateX(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateY(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateY(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateZ(_ angle: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func rotateZ(_ angle: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func viewRH(_ eye: AlterCore.Vec3, _ view: AlterCore.Vec3, _ up: AlterCore.Vec3, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func orthoRH(_ w: Swift.Double, _ h: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func orthoRH(_ w: Swift.Float, _ h: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRH(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRH(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func == (lhs: AlterCore.Mat4, rhs: AlterCore.Mat4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Quaternion : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ r: Swift.Double, _ i: Swift.Double, _ j: Swift.Double, _ k: Swift.Double)
  public convenience init(_ r: Swift.Float, _ i: Swift.Float, _ j: Swift.Float, _ k_: Swift.Float)
  public convenience init(_ vec: AlterCore.Vec4)
  public convenience init()
  public var r: Swift.Float {
    get
  }
  public var i: Swift.Float {
    get
  }
  public var j: Swift.Float {
    get
  }
  public var k: Swift.Float {
    get
  }
  public var ijk: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var mat3RowMajor: AlterCore.Mat3 {
    get
  }
  public var mat3ColumnMajor: AlterCore.Mat3 {
    get
  }
  public var mat4RowMajor: AlterCore.Mat4 {
    get
  }
  public var mat4ColumnMajor: AlterCore.Mat4 {
    get
  }
  public static var identity: AlterCore.Quaternion {
    get
  }
  public func withR(_ r: Swift.Float) -> AlterCore.Quaternion
  public func withI(_ i: Swift.Float) -> AlterCore.Quaternion
  public func withJ(_ j: Swift.Float) -> AlterCore.Quaternion
  public func withK(_ k: Swift.Float) -> AlterCore.Quaternion
  public func mul(_ rhs: AlterCore.Quaternion) -> AlterCore.Quaternion
  public func mul(_ rhs_: AlterCore.Mat3) -> AlterCore.Mat3
  public func mul(_ rhs__: AlterCore.Mat4) -> AlterCore.Mat4
  public func mul(_ rhs___: AlterCore.Vec3) -> AlterCore.Vec3
  public func inverse() -> AlterCore.Quaternion
  public func log() -> AlterCore.Quaternion
  public func exp() -> AlterCore.Quaternion
  public func toRotation() -> AlterCore.KotlinPair<Swift.Float, AlterCore.Vec3>
  public func toEuler() -> AlterCore.Vec3
  public func slerp(_ q: AlterCore.Quaternion, _ t: Swift.Float) -> AlterCore.Quaternion
  public func spline(_ q1: AlterCore.Quaternion, _ q2: AlterCore.Quaternion, _ q3: AlterCore.Quaternion, _ t: Swift.Float) -> AlterCore.Quaternion
  public func toMat3(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat3
  public func toMat4(_ layout: AlterCore.MatrixLayout = MatrixLayout.default_) -> AlterCore.Mat4
  public static func fromMatrix(_ mat: AlterCore.Mat4) -> AlterCore.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> AlterCore.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ vec: AlterCore.Vec3) -> AlterCore.Quaternion
  public static func fromEuler(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> AlterCore.Quaternion
  public static func fromEuler(_ vec: AlterCore.Vec3) -> AlterCore.Quaternion
  public static func == (lhs: AlterCore.Quaternion, rhs: AlterCore.Quaternion) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
}
public protocol VecUnaryOperator {
  func invoke(_ a: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecUnaryOperatorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.VecUnaryOperator {
  public var _wrappedVecUnaryOperator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func invoke(_ a: Swift.Float) -> Swift.Float
}
public protocol VecBinaryOperator {
  func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecBinaryOperatorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.VecBinaryOperator {
  public var _wrappedVecBinaryOperator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class Vec1 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: Swift.Double)
  public convenience init(_ x_: Swift.Float)
  public convenience init(_ x__: Swift.Int)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var xAxis: AlterCore.Vec1 {
    get
  }
  public static var zero: AlterCore.Vec1 {
    get
  }
  public static var one: AlterCore.Vec1 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec1
  public func withY(_ y: Swift.Float) -> AlterCore.Vec2
  public static func == (lhs: AlterCore.Vec1, rhs: AlterCore.Vec1) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Vec2 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: Swift.Double, _ y: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y__: Swift.Int)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public static var xAxis: AlterCore.Vec2 {
    get
  }
  public static var yAxis: AlterCore.Vec2 {
    get
  }
  public static var zero: AlterCore.Vec2 {
    get
  }
  public static var one: AlterCore.Vec2 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec2
  public func withY(_ y: Swift.Float) -> AlterCore.Vec2
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec3
  public func mul(_ mat: AlterCore.Mat2) -> AlterCore.Vec2
  public static func == (lhs: AlterCore.Vec2, rhs: AlterCore.Vec2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Vec3 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ z_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y: Swift.Int, _ z__: Swift.Int)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float)
  public convenience init(_ xyz: Swift.Float)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public static var xAxis: AlterCore.Vec3 {
    get
  }
  public static var yAxis: AlterCore.Vec3 {
    get
  }
  public static var zAxis: AlterCore.Vec3 {
    get
  }
  public static var zero: AlterCore.Vec3 {
    get
  }
  public static var one: AlterCore.Vec3 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec3
  public func withY(_ y: Swift.Float) -> AlterCore.Vec3
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec3
  public func withW(_ w: Swift.Float) -> AlterCore.Vec4
  public func cross(_ rhs: AlterCore.Vec3) -> AlterCore.Vec3
  public func mul(_ mat: AlterCore.Mat3) -> AlterCore.Vec3
  public func mul(_ rhs: AlterCore.Quaternion) -> AlterCore.Vec3
  public static func == (lhs: AlterCore.Vec3, rhs: AlterCore.Vec3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Vec4 : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double)
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w_: Swift.Float)
  public convenience init(_ x: Swift.Int, _ y: Swift.Int, _ z: Swift.Int, _ w__: Swift.Int)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float)
  public convenience init(_ xy: AlterCore.Vec2, _ z: Swift.Float, _ w: Swift.Float)
  public convenience init(_ xy: AlterCore.Vec2, _ zw: AlterCore.Vec2)
  public convenience init(_ xyz: AlterCore.Vec3)
  public convenience init(_ xyz: AlterCore.Vec3, _ w: Swift.Float)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var w: Swift.Float {
    get
  }
  public var xy: AlterCore.Vec2 {
    get
  }
  public var xyz: AlterCore.Vec3 {
    get
  }
  public var xyzw: AlterCore.Vec4 {
    get
  }
  public var rgb: AlterCore.Col {
    get
  }
  public var rgba: AlterCore.Col {
    get
  }
  public static var xAxis: AlterCore.Vec4 {
    get
  }
  public static var yAxis: AlterCore.Vec4 {
    get
  }
  public static var zAxis: AlterCore.Vec4 {
    get
  }
  public static var wAxis: AlterCore.Vec4 {
    get
  }
  public static var zero: AlterCore.Vec4 {
    get
  }
  public static var one: AlterCore.Vec4 {
    get
  }
  public func withX(_ x: Swift.Float) -> AlterCore.Vec4
  public func withY(_ y: Swift.Float) -> AlterCore.Vec4
  public func withZ(_ z: Swift.Float) -> AlterCore.Vec4
  public func withW(_ w: Swift.Float) -> AlterCore.Vec4
  public func dehomog() -> AlterCore.Vec3?
  public func mul(_ mat: AlterCore.Mat4) -> AlterCore.Vec4
  public static func == (lhs: AlterCore.Vec4, rhs: AlterCore.Vec4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class Try<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public var optional: T? {
    get
  }
  public var exception: AlterCore.KotlinException? {
    get
  }
  public var bool_: Swift.Bool {
    get
  }
  public var orThrow: T {
    get
  }
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Try<U>) -> AlterCore.Try<U>
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Try<U>
  public func mapError(_ mapper: @escaping (AlterCore.KotlinException) -> AlterCore.KotlinException) -> AlterCore.Try<T>
  public func `catch`(_ catcher: @escaping (AlterCore.KotlinException) -> T) -> T
  public func catchError(_ catcher: @escaping (AlterCore.TryError) -> T) -> T
  public func or(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<T>) -> AlterCore.Try<T>
  public func flatten<TExt>() -> AlterCore.Try<TExt> where T : AlterCore.Try<TExt>
  public func upcast<SuperType>() -> AlterCore.Try<SuperType>
  public func logError(_ prefix: Swift.String? = nil) -> T?
  public func logWarning(_ prefix: Swift.String? = nil) -> T?
  public func logInfo(_ prefix: Swift.String? = nil) -> T?
  public func logDebug(_ prefix: Swift.String? = nil) -> T?
  public func logInternal(_ prefix: Swift.String? = nil) -> T?
  public func `defer`<TExt>() -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Future<TExt>
  public func defer_<TExt>() -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Observable<TExt>
  public func squash<TExt>() -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Future<AlterCore.Try<TExt>>
  public static func invoke<T>(_ fn: @escaping () -> T) -> AlterCore.Try<T>
  public static func invoke<T>(_ errorContext: Swift.String, _ fn: @escaping () -> T) -> AlterCore.Try<T>
  public static func success<T>(_ value: T) -> AlterCore.Try<T>
  public static func error<T>(_ exception: AlterCore.KotlinException) -> AlterCore.Try<T>
  public static func error<T>(_ message: Swift.String) -> AlterCore.Try<T>
  public static func all<T>(_ items: [AlterCore.Try<T>]) -> AlterCore.Try<[T]>
  public static func == (lhs: AlterCore.Try<T>, rhs: AlterCore.Try<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TryValue<T> : AlterCore.Try<T>, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ value: T)
  public var value: T {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> T
  public func doCopy(_ value: T) -> AlterCore.TryValue<T>
  public static func == (lhs: AlterCore.TryValue<T>, rhs: AlterCore.TryValue<T>) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class TryError : AlterCore.Try<Swift.Never>, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ message: Swift.String)
  public convenience init(_ error: AlterCore.KotlinException)
  public var error: AlterCore.KotlinException {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.KotlinException
  public func doCopy(_ error: AlterCore.KotlinException) -> AlterCore.TryError
  public static func == (lhs: AlterCore.TryError, rhs: AlterCore.TryError) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public protocol KotlinComparable {
  associatedtype T
  func compareTo(_ other: Self.T) -> Swift.Int
}
@_hasMissingDesignatedInitializers public class KotlinComparableWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinComparable {
  public typealias T = T
  public var _wrappedKotlinComparable: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func compareTo(_ other: T) -> Swift.Int
}
public enum FillMode : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case stretch
  case zoom
  case shrink
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.FillMode, b: AlterCore.FillMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PixelComponents : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case r
  case rg
  case rgba
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.PixelComponents, b: AlterCore.PixelComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Image : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public static func == (lhs: AlterCore.Image, rhs: AlterCore.Image) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AlterCore.Image {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.Image {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: AlterCore.KotlinIntArray)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: AlterCore.KotlinIntArray {
      get
    }
    public static func == (lhs: AlterCore.Image.RawInt, rhs: AlterCore.Image.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
extension AlterCore.Image {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.Image {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: AlterCore.KotlinFloatArray, _ pixelComponents: AlterCore.PixelComponents)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: AlterCore.KotlinFloatArray {
      get
    }
    public var pixelComponents: AlterCore.PixelComponents {
      get
    }
    public static func == (lhs: AlterCore.Image.RawFloat, rhs: AlterCore.Image.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
@_hasMissingDesignatedInitializers public class ImageList : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public var images: [AlterCore.Image] {
    get
  }
  public static func == (lhs: AlterCore.ImageList, rhs: AlterCore.ImageList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AlterCore.ImageList {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.ImageList {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: [AlterCore.KotlinIntArray])
    override public var images: [AlterCore.Image] {
      get
    }
    public static func == (lhs: AlterCore.ImageList.RawInt, rhs: AlterCore.ImageList.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
extension AlterCore.ImageList {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.ImageList {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ data: [AlterCore.KotlinFloatArray], _ pixelComponents: AlterCore.PixelComponents)
    override public var images: [AlterCore.Image] {
      get
    }
    public static func == (lhs: AlterCore.ImageList.RawFloat, rhs: AlterCore.ImageList.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
@_hasMissingDesignatedInitializers public class ImageCube : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public static func == (lhs: AlterCore.ImageCube, rhs: AlterCore.ImageCube) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AlterCore.ImageCube {
  @_hasMissingDesignatedInitializers public class RawInt : AlterCore.ImageCube {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ size: Swift.Int, _ xPos: AlterCore.KotlinIntArray, _ xNeg: AlterCore.KotlinIntArray, _ yPos: AlterCore.KotlinIntArray, _ yNeg: AlterCore.KotlinIntArray, _ zPos: AlterCore.KotlinIntArray, _ zNeg: AlterCore.KotlinIntArray)
    public var xPos: AlterCore.Image.RawInt {
      get
    }
    public var xNeg: AlterCore.Image.RawInt {
      get
    }
    public var yPos: AlterCore.Image.RawInt {
      get
    }
    public var yNeg: AlterCore.Image.RawInt {
      get
    }
    public var zPos: AlterCore.Image.RawInt {
      get
    }
    public var zNeg: AlterCore.Image.RawInt {
      get
    }
    public static func == (lhs: AlterCore.ImageCube.RawInt, rhs: AlterCore.ImageCube.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
extension AlterCore.ImageCube {
  @_hasMissingDesignatedInitializers public class RawFloat : AlterCore.ImageCube {
    required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    @objc deinit
    public convenience init(_ size: Swift.Int, _ xPos: AlterCore.KotlinFloatArray, _ xNeg: AlterCore.KotlinFloatArray, _ yPos: AlterCore.KotlinFloatArray, _ yNeg: AlterCore.KotlinFloatArray, _ zPos: AlterCore.KotlinFloatArray, _ zNeg: AlterCore.KotlinFloatArray, _ pixelComponents: AlterCore.PixelComponents)
    public var xPos: AlterCore.Image.RawFloat {
      get
    }
    public var xNeg: AlterCore.Image.RawFloat {
      get
    }
    public var yPos: AlterCore.Image.RawFloat {
      get
    }
    public var yNeg: AlterCore.Image.RawFloat {
      get
    }
    public var zPos: AlterCore.Image.RawFloat {
      get
    }
    public var zNeg: AlterCore.Image.RawFloat {
      get
    }
    public static func == (lhs: AlterCore.ImageCube.RawFloat, rhs: AlterCore.ImageCube.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
  }
}
@_hasMissingDesignatedInitializers public class UIKitImage : AlterCore.Image {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ platformImage: UIKit.UIImage)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var platformImage: UIKit.UIImage {
    get
  }
  public static func == (lhs: AlterCore.UIKitImage, rhs: AlterCore.UIKitImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class MetalImage : AlterCore.Image {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ texture: Metal.MTLTexture)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var texture: Metal.MTLTexture {
    get
  }
  public static func == (lhs: AlterCore.MetalImage, rhs: AlterCore.MetalImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class FaceTrackerResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: AlterCore.Quaternion, _ confidence: Swift.Float, _ inputImageSize: AlterCore.Vec2, _ faceRectangle: AlterCore.Rect, _ positionInCrop: AlterCore.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var normalizedImagePosition: AlterCore.Vec2 {
    get
  }
  public var normalizedImageScale: Swift.Float {
    get
  }
  public var rotationQuaternion: AlterCore.Quaternion {
    get
  }
  public var confidence: Swift.Float {
    get
  }
  public var inputImageSize: AlterCore.Vec2 {
    get
  }
  public var faceRectangle: AlterCore.Rect {
    get
  }
  public var debug: Any? {
    get
  }
  public static var EMPTY: AlterCore.FaceTrackerResult {
    get
  }
  public func hasFace() -> Swift.Bool
  public func interpolate(_ other: AlterCore.FaceTrackerResult, _ t: Swift.Float) -> AlterCore.FaceTrackerResult
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : Swift.Float]
  public func component2() -> AlterCore.Vec2
  public func component3() -> Swift.Float
  public func component4() -> AlterCore.Quaternion
  public func component5() -> Swift.Float
  public func component6() -> AlterCore.Vec2
  public func component7() -> AlterCore.Rect
  public func component10() -> Any?
  public func doCopy(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: AlterCore.Quaternion, _ confidence: Swift.Float, _ inputImageSize: AlterCore.Vec2, _ faceRectangle: AlterCore.Rect, _ positionInCrop: AlterCore.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil) -> AlterCore.FaceTrackerResult
  @available(*, deprecated, renamed: "FaceTrackerResultSerializer", message: "The standalone serialization functions are not future-proof, use the FaceTrackerSerializer and FaceTrackerDeserializer objects instead, they allow exchanging the serialization format too")
  public func serialize(_ customData: AlterCore.KotlinByteArray? = nil) -> AlterCore.KotlinByteArray
  public static func == (lhs: AlterCore.FaceTrackerResult, rhs: AlterCore.FaceTrackerResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerWithResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ tracker: AlterCore.PersistentFaceTracker, _ result: AlterCore.FaceTrackerResult?)
  public var tracker: AlterCore.PersistentFaceTracker {
    get
  }
  public var result: AlterCore.FaceTrackerResult? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.PersistentFaceTracker
  public func component2() -> AlterCore.FaceTrackerResult?
  public func doCopy(_ tracker: AlterCore.PersistentFaceTracker, _ result: AlterCore.FaceTrackerResult?) -> AlterCore.FaceTrackerWithResult
  public static func == (lhs: AlterCore.FaceTrackerWithResult, rhs: AlterCore.FaceTrackerWithResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerImage : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ image: CoreVideo.CVBuffer)
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var image: CoreVideo.CVBuffer {
    get
  }
  public func toUIImage() -> AlterCore.Try<UIKit.UIImage>
  public static func == (lhs: AlterCore.TrackerImage, rhs: AlterCore.TrackerImage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerGPUContext : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public static func == (lhs: AlterCore.TrackerGPUContext, rhs: AlterCore.TrackerGPUContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol PersistentFaceTracker {
  var version: Swift.String { get }
  var blendshapeNames: [Swift.String] { get }
  func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerWithResult
}
@_hasMissingDesignatedInitializers public class PersistentFaceTrackerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.PersistentFaceTracker {
  public var _wrappedPersistentFaceTracker: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var version: Swift.String {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerWithResult
}
@_hasMissingDesignatedInitializers public class FaceTracker : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var lastResult: AlterCore.FaceTrackerResult? {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerResult?
  public static func createVideoTracker(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func createImageTracker(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func == (lhs: AlterCore.FaceTracker, rhs: AlterCore.FaceTracker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FaceTrackerFactory {
  func create(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.PersistentFaceTracker>>
}
@_hasMissingDesignatedInitializers public class FaceTrackerFactoryWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FaceTrackerFactory {
  public var _wrappedFaceTrackerFactory: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func create(_ fileSystem: AlterCore.FileSystem, _ context: AlterCore.TrackerGPUContext) -> AlterCore.Future<AlterCore.Try<AlterCore.PersistentFaceTracker>>
}
public protocol FaceTrackerReprojector {
  func reproject(_ trackerResult: AlterCore.FaceTrackerResult) -> AlterCore.FaceTrackerReprojectorResult
  func reproject(_ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FaceTrackerReprojector {
  public var _wrappedFaceTrackerReprojector: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func reproject(_ trackerResult: AlterCore.FaceTrackerResult) -> AlterCore.FaceTrackerReprojectorResult
  public func reproject(_ normalizedImagePosition: AlterCore.Vec2, _ normalizedImageScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorResult : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ spatialPosition: AlterCore.Vec3, _ spatialScale: Swift.Float)
  public var spatialPosition: AlterCore.Vec3 {
    get
  }
  public var spatialScale: Swift.Float {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.Vec3
  public func component2() -> Swift.Float
  public func doCopy(_ spatialPosition: AlterCore.Vec3, _ spatialScale: Swift.Float) -> AlterCore.FaceTrackerReprojectorResult
  public static func == (lhs: AlterCore.FaceTrackerReprojectorResult, rhs: AlterCore.FaceTrackerReprojectorResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectors : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: AlterCore.FillMode, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: AlterCore.FillMode, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  public static func == (lhs: AlterCore.FaceTrackerReprojectors, rhs: AlterCore.FaceTrackerReprojectors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerResultSerializer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializationFormat: AlterCore.KotlinByteArray {
    get
  }
  public func serialize(_ trackerResult: AlterCore.FaceTrackerResult, _ userData: AlterCore.KotlinByteArray? = nil) -> AlterCore.KotlinByteArray
  public static func create() -> AlterCore.FaceTrackerResultSerializer
  public static func == (lhs: AlterCore.FaceTrackerResultSerializer, rhs: AlterCore.FaceTrackerResultSerializer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeserializedResult : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ trackerResult: AlterCore.FaceTrackerResult, _ userData: AlterCore.KotlinByteArray?)
  @available(*, deprecated, message: "Renamed to trackerResult")
  public var first: AlterCore.FaceTrackerResult {
    get
  }
  @available(*, deprecated, message: "Renamed to userData")
  public var second: AlterCore.KotlinByteArray? {
    get
  }
  public var trackerResult: AlterCore.FaceTrackerResult {
    get
  }
  public var userData: AlterCore.KotlinByteArray? {
    get
  }
  public func component1() -> AlterCore.FaceTrackerResult
  public func component2() -> AlterCore.KotlinByteArray?
  public static func == (lhs: AlterCore.DeserializedResult, rhs: AlterCore.DeserializedResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerResultDeserializer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func deserialize(_ data: AlterCore.KotlinByteArray) -> AlterCore.DeserializedResult
  public static func create(_ serializationFormat: AlterCore.KotlinByteArray) -> AlterCore.FaceTrackerResultDeserializer
  public static func == (lhs: AlterCore.FaceTrackerResultDeserializer, rhs: AlterCore.FaceTrackerResultDeserializer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Rect : AlterCore.Vector {
  public typealias T = AlterCore.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ x: Swift.Float, _ y: Swift.Float, _ width: Swift.Float, _ height: Swift.Float)
  public convenience init(_ origin: AlterCore.Vec2, _ size: AlterCore.Vec2)
  public convenience init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var width: Swift.Float {
    get
  }
  public var height: Swift.Float {
    get
  }
  public var origin: AlterCore.Vec2 {
    get
  }
  public var extent: AlterCore.Vec2 {
    get
  }
  public var minX: Swift.Float {
    get
  }
  public var minY: Swift.Float {
    get
  }
  public var maxX: Swift.Float {
    get
  }
  public var maxY: Swift.Float {
    get
  }
  public static var FULL: AlterCore.Rect {
    get
  }
  public func area() -> Swift.Float
  public func expandToSquare() -> AlterCore.Rect
  public func scaleWidthHeight(_ sw: Swift.Float, _ sh: Swift.Float) -> AlterCore.Rect
  public func scaleXY(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func scale(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func scale(_ s: AlterCore.Vec2) -> AlterCore.Rect
  public func scaleAroundCenter(_ sx: Swift.Float, _ sy: Swift.Float) -> AlterCore.Rect
  public func offset(_ dx: Swift.Float, _ dy: Swift.Float) -> AlterCore.Rect
  public func flipY(_ maxHeight: Swift.Float = 1.n) -> AlterCore.Rect
  public func toArray() -> AlterCore.KotlinFloatArray
  public func toFloatArray() -> AlterCore.KotlinFloatArray
  public func insetBy(_ dx: Swift.Float, _ dy: Swift.Float) -> AlterCore.Rect
  public func normalizeBy(_ size: AlterCore.Vec2) -> AlterCore.Rect
  public static func == (lhs: AlterCore.Rect, rhs: AlterCore.Rect) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
public protocol File {
  var path: AlterCore.Path { get }
  var fileSystem: AlterCore.FileSystem { get }
  func readAllBytes() -> AlterCore.Future<AlterCore.Try<AlterCore.KotlinByteArray>>
  func readAllText() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  func readImage() -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
  func readJson() -> AlterCore.Future<AlterCore.Try<AlterCore.DecodedJson>>
}
@_hasMissingDesignatedInitializers public class FileWrapper : AlterCore.ConvertibleToKotlin, AlterCore.File {
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var path: AlterCore.Path {
    get
  }
  public var fileSystem: AlterCore.FileSystem {
    get
  }
  public func readAllBytes() -> AlterCore.Future<AlterCore.Try<AlterCore.KotlinByteArray>>
  public func readAllText() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  public func readImage() -> AlterCore.Future<AlterCore.Try<AlterCore.Image>>
  public func readJson() -> AlterCore.Future<AlterCore.Try<AlterCore.DecodedJson>>
}
public protocol FileSystem {
  var root: AlterCore.Path { get }
  func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
}
@_hasMissingDesignatedInitializers public class FileSystemWrapper : AlterCore.ConvertibleToKotlin, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
}
public protocol WriteableFileSystem : AlterCore.FileSystem {
  func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64?) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
}
@_hasMissingDesignatedInitializers public class WriteableFileSystemWrapper : AlterCore.ConvertibleToKotlin, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
}
@_hasMissingDesignatedInitializers public class ApplicationContext : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ bundle: Foundation.Bundle = defaultBundle())
  public var bundle: Foundation.Bundle {
    get
  }
  public static func == (lhs: AlterCore.ApplicationContext, rhs: AlterCore.ApplicationContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResourceFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public convenience init(_ context: AlterCore.ApplicationContext, _ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func create(_ context: AlterCore.ApplicationContext) -> AlterCore.ResourceFileSystem
  public static func create(_ context: AlterCore.ApplicationContext, _ root: AlterCore.Path) -> AlterCore.ResourceFileSystem
  public static func == (lhs: AlterCore.ResourceFileSystem, rhs: AlterCore.ResourceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public static func create(_ root: AlterCore.Path) -> AlterCore.DeviceFileSystem
  public static func == (lhs: AlterCore.DeviceFileSystem, rhs: AlterCore.DeviceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NetworkFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path)
  public var session: Foundation.URLSession {
    get
  }
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func create(_ serverUrl: Swift.String) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: AlterCore.Path) -> AlterCore.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path) -> AlterCore.NetworkFileSystem
  public static func == (lhs: AlterCore.NetworkFileSystem, rhs: AlterCore.NetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableNetworkFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem, AlterCore.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> AlterCore.Future<Swift.Set<Swift.String>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func create(_ serverUrl: Swift.String) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: AlterCore.Path) -> AlterCore.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: AlterCore.Path) -> AlterCore.WriteableNetworkFileSystem
  public static func == (lhs: AlterCore.WriteableNetworkFileSystem, rhs: AlterCore.WriteableNetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSubSystem<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem where T : AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ parent: T, _ newRoot: AlterCore.Path)
  public var root: AlterCore.Path {
    get
  }
  public var parent: T {
    get
  }
  public var newRoot: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func == (lhs: AlterCore.FileSubSystem<T>, rhs: AlterCore.FileSubSystem<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableFileSubSystem : AlterCore.FileSubSystem<AlterCore.WriteableFileSystemWrapper>, AlterCore.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  override public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ parent: AlterCore.WriteableFileSystem, _ newRoot: AlterCore.Path)
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public static func == (lhs: AlterCore.WriteableFileSubSystem, rhs: AlterCore.WriteableFileSubSystem) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class FallbackFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ filesystems: AlterCore.KotlinArray<AlterCore.FileSystem>)
  public convenience init(_ filesystems_: [AlterCore.FileSystem])
  public var root: AlterCore.Path {
    get
  }
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func == (lhs: AlterCore.FallbackFileSystem, rhs: AlterCore.FallbackFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DevelopmentFileSystem : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.FileSystem, AlterCore.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ root: AlterCore.Path, _ resourceDirsOverride: [Swift.String], _ port: Swift.String = "8000")
  public convenience init(_ root: AlterCore.Path = Path(""), _ resourceDirsOverride: AlterCore.KotlinArray<Swift.String>? = nil, _ port_: Swift.String = "8000")
  public var root: AlterCore.Path {
    get
  }
  public func writeFile(_ path: AlterCore.Path, _ bytes: AlterCore.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> AlterCore.Future<AlterCore.Try<Swift.Void>>
  public func fileAt(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.File>>
  public func watch(_ path: AlterCore.Path) -> AlterCore.Observable<AlterCore.Try<AlterCore.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> AlterCore.Future<Swift.Set<Swift.String>>
  public func exists(_ path: AlterCore.Path) -> AlterCore.Future<Swift.Bool>
  public func lastModified(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<Swift.Int64>>
  public func url(_ path: AlterCore.Path) -> AlterCore.Try<Swift.String>
  public static func == (lhs: AlterCore.DevelopmentFileSystem, rhs: AlterCore.DevelopmentFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSystemWatcher : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: AlterCore.FileWatchErrorSensitivity = .medium)
  public func watch<T>(_ noChangeValue: T, _ watcher: @escaping (AlterCore.FileSystem) -> T) -> T
  public func watch<T>(_ noChangeValue: T, _ fileSystem: AlterCore.FileSystem, _ watcher: @escaping (AlterCore.FileSystem) -> T) -> T
  public func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (AlterCore.FileSystem) -> AlterCore.Future<T>) -> AlterCore.Future<T>
  public static func == (lhs: AlterCore.FileSystemWatcher, rhs: AlterCore.FileSystemWatcher) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum FileWatchErrorSensitivity : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case low
  case medium
  case high
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.FileWatchErrorSensitivity, b: AlterCore.FileWatchErrorSensitivity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class JsonEncoderDecoderClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var json: AlterCore.Kotlinx_serialization_jsonJson {
    get
  }
  public func parseJson<T, TKotlinx_serialization_coreDeserializationStrategy>(_ jsonText: Swift.String, _ strategy: TKotlinx_serialization_coreDeserializationStrategy) -> AlterCore.Try<T> where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToString<T>(_ value: T) -> Swift.String
  public func decodeFromString<T>(_ value: Swift.String) -> AlterCore.Try<T>
  public static func == (lhs: AlterCore.JsonEncoderDecoderClass, rhs: AlterCore.JsonEncoderDecoderClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public var JsonEncoderDecoder: AlterCore.JsonEncoderDecoderClass
public protocol DecodedJson {
  var size: Swift.Int { get }
  var keys: Any { get }
  func get(_ key: Swift.String) -> AlterCore.DecodedJson?
  func get(_ index: Swift.Int) -> AlterCore.DecodedJson?
  func getString(_ key: Swift.String) -> Swift.String?
  func getString(_ index: Swift.Int) -> Swift.String?
  func getInt(_ key: Swift.String) -> Swift.Int?
  func getInt(_ index: Swift.Int) -> Swift.Int?
  func getDouble(_ key: Swift.String) -> Swift.Double?
  func getDouble(_ index: Swift.Int) -> Swift.Double?
  func getBool(_ key: Swift.String) -> Swift.Bool?
  func getBool(_ index: Swift.Int) -> Swift.Bool?
}
@_hasMissingDesignatedInitializers public class DecodedJsonWrapper : AlterCore.ConvertibleToKotlin, AlterCore.DecodedJson {
  public var _wrappedDecodedJson: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var size: Swift.Int {
    get
  }
  public var keys: Any {
    get
  }
  public func get(_ key: Swift.String) -> AlterCore.DecodedJson?
  public func get(_ index: Swift.Int) -> AlterCore.DecodedJson?
  public func getString(_ key: Swift.String) -> Swift.String?
  public func getString(_ index: Swift.Int) -> Swift.String?
  public func getInt(_ key: Swift.String) -> Swift.Int?
  public func getInt(_ index: Swift.Int) -> Swift.Int?
  public func getDouble(_ key: Swift.String) -> Swift.Double?
  public func getDouble(_ index: Swift.Int) -> Swift.Double?
  public func getBool(_ key: Swift.String) -> Swift.Bool?
  public func getBool(_ index: Swift.Int) -> Swift.Bool?
}
@_hasMissingDesignatedInitializers public class Path : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ path: Swift.String)
  public func lastComponent() -> Swift.String
  public func `extension`() -> Swift.String
  public func baseName() -> Swift.String
  public func directory() -> AlterCore.Path
  public func join(_ path: Swift.String) -> AlterCore.Path
  public func join(_ path_: AlterCore.Path) -> AlterCore.Path
  public func div(_ path: Swift.String) -> AlterCore.Path
  public func div(_ path_: AlterCore.Path) -> AlterCore.Path
  public func normalized() -> AlterCore.Path
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func doCopy(_ path: Swift.String) -> AlterCore.Path
  public static func == (lhs: AlterCore.Path, rhs: AlterCore.Path) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class CommonEmotionsClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var HAPPY: [Swift.String : Swift.Float] {
    get
  }
  public var SAD: [Swift.String : Swift.Float] {
    get
  }
  public var ANGRY: [Swift.String : Swift.Float] {
    get
  }
  public var VICIOUS: [Swift.String : Swift.Float] {
    get
  }
  public var SURPRISED: [Swift.String : Swift.Float] {
    get
  }
  public var SCARED: [Swift.String : Swift.Float] {
    get
  }
  public static func == (lhs: AlterCore.CommonEmotionsClass, rhs: AlterCore.CommonEmotionsClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public var CommonEmotions: AlterCore.CommonEmotionsClass
public protocol AvatarDesignerLogic {
  func avatarPresets() -> [AlterCore.AvatarPresetDefinition]
  func updateConfiguration(_ config: AlterCore.DesignerConfigurationDefinition, _ selections: AlterCore.SelectionsDefinition) -> AlterCore.DesignerConfigurationDefinition
  func selectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ itemVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  func deselectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String) -> AlterCore.DesignerConfigurationDefinition
  func selectMaterial(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ materialPickerName: Swift.String, _ materialVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  func selectColor(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ colorPickerName: Swift.String, _ colorVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  func configurationToAvatarMatrix(_ config: AlterCore.DesignerConfigurationDefinition) -> AlterCore.AvatarMatrix
  func avatarMatrixToConfiguration(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.DesignerConfigurationDefinition
}
@_hasMissingDesignatedInitializers public class AvatarDesignerLogicWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarDesignerLogic {
  public var _wrappedAvatarDesignerLogic: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func avatarPresets() -> [AlterCore.AvatarPresetDefinition]
  public func updateConfiguration(_ config: AlterCore.DesignerConfigurationDefinition, _ selections: AlterCore.SelectionsDefinition) -> AlterCore.DesignerConfigurationDefinition
  public func selectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ itemVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func deselectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String) -> AlterCore.DesignerConfigurationDefinition
  public func selectMaterial(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ materialPickerName: Swift.String, _ materialVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func selectColor(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ colorPickerName: Swift.String, _ colorVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func configurationToAvatarMatrix(_ config: AlterCore.DesignerConfigurationDefinition) -> AlterCore.AvatarMatrix
  public func avatarMatrixToConfiguration(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.DesignerConfigurationDefinition
}
@_hasMissingDesignatedInitializers public class ConfigurableAvatarDesignerLogic : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarDesignerLogic {
  public var _wrappedAvatarDesignerLogic: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public static var DEFAULT_LOCALE: Swift.String {
    get
  }
  public func avatarPresets() -> [AlterCore.AvatarPresetDefinition]
  public func updateConfiguration(_ config: AlterCore.DesignerConfigurationDefinition, _ selections: AlterCore.SelectionsDefinition) -> AlterCore.DesignerConfigurationDefinition
  public func selectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ itemVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func deselectItem(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String) -> AlterCore.DesignerConfigurationDefinition
  public func selectMaterial(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ materialPickerName: Swift.String, _ materialVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func selectColor(_ config: AlterCore.DesignerConfigurationDefinition, _ itemName: Swift.String, _ colorPickerName: Swift.String, _ colorVariantIndex: Swift.Int) -> AlterCore.DesignerConfigurationDefinition
  public func configurationToAvatarMatrix(_ config: AlterCore.DesignerConfigurationDefinition) -> AlterCore.AvatarMatrix
  public func avatarMatrixToConfiguration(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.DesignerConfigurationDefinition
  public static func create(_ dataFileSystem: AlterCore.FileSystem, _ logicConfigFileSystem: AlterCore.FileSystem? = nil, _ configFilePath: Swift.String = "jsons/designerlogic/logic_configuration.json", _ localeCode: Swift.String = DEFAULT_LOCALE, _ thumbnailSuffixAndExtension: Swift.String = ".png", _ warnOnIncompleteData: Swift.Bool = true) -> AlterCore.Future<AlterCore.Try<AlterCore.ConfigurableAvatarDesignerLogic>>
  public static func create(_ avatarFactory: AlterCore.AvatarFactory, _ logicConfigFileSystem: AlterCore.FileSystem? = nil, _ configFilePath: Swift.String = "jsons/designerlogic/logic_configuration.json", _ localeCode: Swift.String = DEFAULT_LOCALE, _ thumbnailSuffixAndExtension: Swift.String = ".png", _ warnOnIncompleteData: Swift.Bool = true) -> AlterCore.Future<AlterCore.Try<AlterCore.ConfigurableAvatarDesignerLogic>>
  public static func == (lhs: AlterCore.ConfigurableAvatarDesignerLogic, rhs: AlterCore.ConfigurableAvatarDesignerLogic) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AssetListGenerator : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device, _ logFilter: ((Swift.String) -> Swift.Bool)? = nil)
  public func scanAssets(_ matrixPaths: Any, _ fileWithItemList: Swift.String) -> AlterCore.Future<AlterCore.Try<[Swift.String]>>
  public static func == (lhs: AlterCore.AssetListGenerator, rhs: AlterCore.AssetListGenerator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum GeneratorMode : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case position
  case rotation
  case scale
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.GeneratorMode, b: AlterCore.GeneratorMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AvatarController {
  func frame() -> AlterCore.AvatarAnimationData?
}
@_hasMissingDesignatedInitializers public class AvatarControllerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func frame() -> AlterCore.AvatarAnimationData?
}
@_hasMissingDesignatedInitializers public class GeneratorController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ changeMode: AlterCore.GeneratorMode, _ renderer: AlterCore.AvatarRenderer, _ startingPosition: AlterCore.AvatarAnimationData)
  public func pointerMove(_ x: Swift.Float, _ y: Swift.Float)
  public func pointerDown(_ x: Swift.Float, _ y: Swift.Float)
  public func pointerUp(_ x: Swift.Float, _ y: Swift.Float)
  public func decreaseScale()
  public func increaseScale()
  public func frame() -> AlterCore.AvatarAnimationData?
  public func setGeneratorMode(_ mode: AlterCore.GeneratorMode)
  public static func == (lhs: AlterCore.GeneratorController, rhs: AlterCore.GeneratorController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemMetadataAndThumbnailBatchGenerator : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ loader: AlterCore.AvatarLoader, _ renderer: AlterCore.AvatarRenderer, _ fileSystem: AlterCore.WriteableFileSystem, _ imageConvertor: @escaping (AlterCore.UIKitImage) -> AlterCore.KotlinByteArray)
  public func generateThumbnails(_ fileWithItemList: Swift.String, _ width: Swift.Int, _ height: Swift.Int, _ superSampling: Swift.Float, _ saveMetadata: Swift.Bool, _ saveThumbnail: Swift.Bool) -> AlterCore.Future<Swift.Void?>
  public static func == (lhs: AlterCore.ItemMetadataAndThumbnailBatchGenerator, rhs: AlterCore.ItemMetadataAndThumbnailBatchGenerator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemMetadataAndThumbnailGenerator : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var controller: AlterCore.GeneratorController {
    get
  }
  public func generateThumbnails(_ width: Swift.Int, _ height: Swift.Int, _ superSampling: Swift.Float, _ saveConfig: Swift.Bool = true, _ saveMetadata: Swift.Bool = true, _ saveThumbnail: Swift.Bool = true) -> AlterCore.Future<Swift.Void>
  public static func create(_ loader: AlterCore.AvatarLoader, _ renderer: AlterCore.AvatarRenderer, _ fileSystem: AlterCore.WriteableFileSystem, _ itemReference: AlterCore.ItemReferenceDefinition, _ overrideMatrix: AlterCore.AvatarMatrix? = nil, _ overrideView: AlterCore.AvatarAnimationData? = nil, _ imageConvertor: @escaping (AlterCore.UIKitImage) -> AlterCore.KotlinByteArray) -> AlterCore.Future<AlterCore.Try<AlterCore.ItemMetadataAndThumbnailGenerator>>
  public static func == (lhs: AlterCore.ItemMetadataAndThumbnailGenerator, rhs: AlterCore.ItemMetadataAndThumbnailGenerator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ThumbnailConfigDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ matrix: AlterCore.AvatarMatrix, _ view: AlterCore.TransformDefinition, _ properties: [Swift.String : Swift.String] = [:], _ completeMatrix: Swift.Bool = false)
  public var matrix: AlterCore.AvatarMatrix {
    get
  }
  public var view: AlterCore.TransformDefinition {
    get
  }
  public var properties: [Swift.String : Swift.String] {
    get
  }
  public var completeMatrix: Swift.Bool {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.AvatarMatrix
  public func component2() -> AlterCore.TransformDefinition
  public func component3() -> [Swift.String : Swift.String]
  public func component4() -> Swift.Bool
  public func doCopy(_ matrix: AlterCore.AvatarMatrix, _ view: AlterCore.TransformDefinition, _ properties: [Swift.String : Swift.String] = [:], _ completeMatrix: Swift.Bool = false) -> AlterCore.ThumbnailConfigDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ThumbnailConfigDefinition
  public static func == (lhs: AlterCore.ThumbnailConfigDefinition, rhs: AlterCore.ThumbnailConfigDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarPresetDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ thumbnailPath: Swift.String, _ avatarMatrix: AlterCore.AvatarMatrix)
  public var thumbnailPath: Swift.String {
    get
  }
  public var avatarMatrix: AlterCore.AvatarMatrix {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> AlterCore.AvatarMatrix
  public func doCopy(_ thumbnailPath: Swift.String, _ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.AvatarPresetDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarPresetDefinition
  public static func == (lhs: AlterCore.AvatarPresetDefinition, rhs: AlterCore.AvatarPresetDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemSelectionDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ itemVariantIndex: Swift.Int, _ libraryVariants: [Swift.String : Swift.String], _ materialPicks: [Swift.String : Swift.Int], _ colorPicks: [Swift.String : Swift.Int])
  public var itemVariantIndex: Swift.Int {
    get
  }
  public var libraryVariants: [Swift.String : Swift.String] {
    get
  }
  public var materialPicks: [Swift.String : Swift.Int] {
    get
  }
  public var colorPicks: [Swift.String : Swift.Int] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.Int
  public func component2() -> [Swift.String : Swift.String]
  public func component3() -> [Swift.String : Swift.Int]
  public func component4() -> [Swift.String : Swift.Int]
  public func doCopy(_ itemVariantIndex: Swift.Int, _ libraryVariants: [Swift.String : Swift.String], _ materialPicks: [Swift.String : Swift.Int], _ colorPicks: [Swift.String : Swift.Int]) -> AlterCore.ItemSelectionDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemSelectionDefinition
  public static func == (lhs: AlterCore.ItemSelectionDefinition, rhs: AlterCore.ItemSelectionDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SelectionsDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ selectedItems: [Swift.String : AlterCore.ItemSelectionDefinition], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:])
  public var selectedItems: [Swift.String : AlterCore.ItemSelectionDefinition] {
    get
  }
  public var boneBlenderWeights: [Swift.String : Swift.Float] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.ItemSelectionDefinition]
  public func component2() -> [Swift.String : Swift.Float]
  public func doCopy(_ selectedItems: [Swift.String : AlterCore.ItemSelectionDefinition], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:]) -> AlterCore.SelectionsDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.SelectionsDefinition
  public static func == (lhs: AlterCore.SelectionsDefinition, rhs: AlterCore.SelectionsDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SectionItemReferenceDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ itemVariantIndex: Swift.Int)
  public var name: Swift.String {
    get
  }
  public var itemVariantIndex: Swift.Int {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.Int
  public func doCopy(_ name: Swift.String, _ itemVariantIndex: Swift.Int) -> AlterCore.SectionItemReferenceDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.SectionItemReferenceDefinition
  public static func == (lhs: AlterCore.SectionItemReferenceDefinition, rhs: AlterCore.SectionItemReferenceDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SectionConfigurationDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ items: [Swift.String : [Swift.Int]], _ itemsFlat: [AlterCore.SectionItemReferenceDefinition], _ maxSelections: Swift.Int, _ mandatorySelection: Swift.Bool)
  public var items: [Swift.String : [Swift.Int]] {
    get
  }
  public var itemsFlat: [AlterCore.SectionItemReferenceDefinition] {
    get
  }
  public var maxSelections: Swift.Int {
    get
  }
  public var mandatorySelection: Swift.Bool {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : [Swift.Int]]
  public func component2() -> [AlterCore.SectionItemReferenceDefinition]
  public func component3() -> Swift.Int
  public func component4() -> Swift.Bool
  public func doCopy(_ items: [Swift.String : [Swift.Int]], _ itemsFlat: [AlterCore.SectionItemReferenceDefinition], _ maxSelections: Swift.Int, _ mandatorySelection: Swift.Bool) -> AlterCore.SectionConfigurationDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.SectionConfigurationDefinition
  public static func == (lhs: AlterCore.SectionConfigurationDefinition, rhs: AlterCore.SectionConfigurationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SectionNodeDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ title: Swift.String, _ subsections: [AlterCore.SectionNodeDefinition]? = nil)
  public var name: Swift.String {
    get
  }
  public var title: Swift.String {
    get
  }
  public var subsections: [AlterCore.SectionNodeDefinition]? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.String
  public func component3() -> [AlterCore.SectionNodeDefinition]?
  public func doCopy(_ name: Swift.String, _ title: Swift.String, _ subsections: [AlterCore.SectionNodeDefinition]? = nil) -> AlterCore.SectionNodeDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.SectionNodeDefinition
  public static func == (lhs: AlterCore.SectionNodeDefinition, rhs: AlterCore.SectionNodeDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum ItemState : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case valid
  case hidden
  case unavailable
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.ItemState, b: AlterCore.ItemState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerConfigurationDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ items: [Swift.String : AlterCore.ItemMetadataDefinition], _ itemStates: [Swift.String : AlterCore.ItemState], _ sectionHierarchy: [AlterCore.SectionNodeDefinition], _ sections: [Swift.String : AlterCore.SectionConfigurationDefinition], _ selections: AlterCore.SelectionsDefinition)
  public var items: [Swift.String : AlterCore.ItemMetadataDefinition] {
    get
  }
  public var itemStates: [Swift.String : AlterCore.ItemState] {
    get
  }
  public var sectionHierarchy: [AlterCore.SectionNodeDefinition] {
    get
  }
  public var sections: [Swift.String : AlterCore.SectionConfigurationDefinition] {
    get
  }
  public var selections: AlterCore.SelectionsDefinition {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.ItemMetadataDefinition]
  public func component2() -> [Swift.String : AlterCore.ItemState]
  public func component3() -> [AlterCore.SectionNodeDefinition]
  public func component4() -> [Swift.String : AlterCore.SectionConfigurationDefinition]
  public func component5() -> AlterCore.SelectionsDefinition
  public func doCopy(_ items: [Swift.String : AlterCore.ItemMetadataDefinition], _ itemStates: [Swift.String : AlterCore.ItemState], _ sectionHierarchy: [AlterCore.SectionNodeDefinition], _ sections: [Swift.String : AlterCore.SectionConfigurationDefinition], _ selections: AlterCore.SelectionsDefinition) -> AlterCore.DesignerConfigurationDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerConfigurationDefinition
  public static func == (lhs: AlterCore.DesignerConfigurationDefinition, rhs: AlterCore.DesignerConfigurationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerLogicSectionNodeDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ subsections: [AlterCore.DesignerLogicSectionNodeDefinition]? = nil)
  public var name: Swift.String {
    get
  }
  public var subsections: [AlterCore.DesignerLogicSectionNodeDefinition]? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [AlterCore.DesignerLogicSectionNodeDefinition]?
  public func doCopy(_ name: Swift.String, _ subsections: [AlterCore.DesignerLogicSectionNodeDefinition]? = nil) -> AlterCore.DesignerLogicSectionNodeDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerLogicSectionNodeDefinition
  public static func == (lhs: AlterCore.DesignerLogicSectionNodeDefinition, rhs: AlterCore.DesignerLogicSectionNodeDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerLogicSectionRuleDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ and: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ or: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ not: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ tagsAll: [Swift.String : Swift.String]? = nil, _ tagsAny: [Swift.String : [Swift.String]]? = nil, _ tagsAnyForAll: [Swift.String : [Swift.String]]? = nil, _ greedyRule: Swift.Bool = true)
  public var and_: [AlterCore.DesignerLogicSectionRuleDefinition]? {
    get
  }
  public var or_: [AlterCore.DesignerLogicSectionRuleDefinition]? {
    get
  }
  public var not_: [AlterCore.DesignerLogicSectionRuleDefinition]? {
    get
  }
  public var tagsAll: [Swift.String : Swift.String]? {
    get
  }
  public var tagsAny: [Swift.String : [Swift.String]]? {
    get
  }
  public var tagsAnyForAll: [Swift.String : [Swift.String]]? {
    get
  }
  public var greedyRule: Swift.Bool {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [AlterCore.DesignerLogicSectionRuleDefinition]?
  public func component2() -> [AlterCore.DesignerLogicSectionRuleDefinition]?
  public func component3() -> [AlterCore.DesignerLogicSectionRuleDefinition]?
  public func component4() -> [Swift.String : Swift.String]?
  public func component5() -> [Swift.String : [Swift.String]]?
  public func component6() -> [Swift.String : [Swift.String]]?
  public func component7() -> Swift.Bool
  public func doCopy(_ and: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ or: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ not: [AlterCore.DesignerLogicSectionRuleDefinition]? = nil, _ tagsAll: [Swift.String : Swift.String]? = nil, _ tagsAny: [Swift.String : [Swift.String]]? = nil, _ tagsAnyForAll: [Swift.String : [Swift.String]]? = nil, _ greedyRule: Swift.Bool = true) -> AlterCore.DesignerLogicSectionRuleDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerLogicSectionRuleDefinition
  public static func == (lhs: AlterCore.DesignerLogicSectionRuleDefinition, rhs: AlterCore.DesignerLogicSectionRuleDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerLogicSectionConfigurationDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ rule: AlterCore.DesignerLogicSectionRuleDefinition, _ maxSelections: Swift.Int, _ mandatorySelection: Swift.Bool)
  public var rule: AlterCore.DesignerLogicSectionRuleDefinition {
    get
  }
  public var maxSelections: Swift.Int {
    get
  }
  public var mandatorySelection: Swift.Bool {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.DesignerLogicSectionRuleDefinition
  public func component2() -> Swift.Int
  public func component3() -> Swift.Bool
  public func doCopy(_ rule: AlterCore.DesignerLogicSectionRuleDefinition, _ maxSelections: Swift.Int, _ mandatorySelection: Swift.Bool) -> AlterCore.DesignerLogicSectionConfigurationDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerLogicSectionConfigurationDefinition
  public static func == (lhs: AlterCore.DesignerLogicSectionConfigurationDefinition, rhs: AlterCore.DesignerLogicSectionConfigurationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerLogicConfigurationDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ avatarPresetsPath: Swift.String, _ sectionHierarchy: [AlterCore.DesignerLogicSectionNodeDefinition], _ sectionConfigurations: [Swift.String : AlterCore.DesignerLogicSectionConfigurationDefinition])
  public var avatarPresetsPath: Swift.String {
    get
  }
  public var sectionHierarchy: [AlterCore.DesignerLogicSectionNodeDefinition] {
    get
  }
  public var sectionConfigurations: [Swift.String : AlterCore.DesignerLogicSectionConfigurationDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [AlterCore.DesignerLogicSectionNodeDefinition]
  public func component3() -> [Swift.String : AlterCore.DesignerLogicSectionConfigurationDefinition]
  public func doCopy(_ avatarPresetsPath: Swift.String, _ sectionHierarchy: [AlterCore.DesignerLogicSectionNodeDefinition], _ sectionConfigurations: [Swift.String : AlterCore.DesignerLogicSectionConfigurationDefinition]) -> AlterCore.DesignerLogicConfigurationDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerLogicConfigurationDefinition
  public static func == (lhs: AlterCore.DesignerLogicConfigurationDefinition, rhs: AlterCore.DesignerLogicConfigurationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DesignerLogicLocaleDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ sectionTitles: [Swift.String : Swift.String])
  public var sectionTitles: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : Swift.String]
  public func doCopy(_ sectionTitles: [Swift.String : Swift.String]) -> AlterCore.DesignerLogicLocaleDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.DesignerLogicLocaleDefinition
  public static func == (lhs: AlterCore.DesignerLogicLocaleDefinition, rhs: AlterCore.DesignerLogicLocaleDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialPickerMetadataDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String, _ variants: [AlterCore.MaterialPickerVariantMetadataDefinition])
  public var title: Swift.String {
    get
  }
  public var variants: [AlterCore.MaterialPickerVariantMetadataDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [AlterCore.MaterialPickerVariantMetadataDefinition]
  public func doCopy(_ title: Swift.String, _ variants: [AlterCore.MaterialPickerVariantMetadataDefinition]) -> AlterCore.MaterialPickerMetadataDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialPickerMetadataDefinition
  public static func == (lhs: AlterCore.MaterialPickerMetadataDefinition, rhs: AlterCore.MaterialPickerMetadataDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialPickerVariantMetadataDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ variantName: Swift.String, _ thumbnailPath: Swift.String, _ tags: [Swift.String : Swift.String] = [:])
  public var variantName: Swift.String {
    get
  }
  public var thumbnailPath: Swift.String {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.String
  public func component3() -> [Swift.String : Swift.String]
  public func doCopy(_ variantName: Swift.String, _ thumbnailPath: Swift.String, _ tags: [Swift.String : Swift.String] = [:]) -> AlterCore.MaterialPickerVariantMetadataDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialPickerVariantMetadataDefinition
  public static func == (lhs: AlterCore.MaterialPickerVariantMetadataDefinition, rhs: AlterCore.MaterialPickerVariantMetadataDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ColorPickerMetadataDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String, _ palette: AlterCore.PaletteDefinition, _ propertiesToPaletteValues: [Swift.String : Swift.String], _ paletteValuesToProperties: [Swift.String : [Swift.String]], _ limitedToMaterialPicks: [Swift.String : Swift.String]? = nil)
  public var title: Swift.String {
    get
  }
  public var palette: AlterCore.PaletteDefinition {
    get
  }
  public var propertiesToPaletteValues: [Swift.String : Swift.String] {
    get
  }
  public var paletteValuesToProperties: [Swift.String : [Swift.String]] {
    get
  }
  public var limitedToMaterialPicks: [Swift.String : Swift.String]? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> AlterCore.PaletteDefinition
  public func component3() -> [Swift.String : Swift.String]
  public func component4() -> [Swift.String : [Swift.String]]
  public func component5() -> [Swift.String : Swift.String]?
  public func doCopy(_ title: Swift.String, _ palette: AlterCore.PaletteDefinition, _ propertiesToPaletteValues: [Swift.String : Swift.String], _ paletteValuesToProperties: [Swift.String : [Swift.String]], _ limitedToMaterialPicks: [Swift.String : Swift.String]? = nil) -> AlterCore.ColorPickerMetadataDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ColorPickerMetadataDefinition
  public static func == (lhs: AlterCore.ColorPickerMetadataDefinition, rhs: AlterCore.ColorPickerMetadataDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemVariantMetadataDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String? = nil, _ thumbnailPath: Swift.String, _ tags: [Swift.String : Swift.String] = [:], _ materialPickers: [Swift.String : AlterCore.MaterialPickerMetadataDefinition] = [:], _ colorPickers: [Swift.String : AlterCore.ColorPickerMetadataDefinition] = [:], _ libraryVariants: [Swift.String : Swift.String] = [:])
  public var title: Swift.String? {
    get
  }
  public var thumbnailPath: Swift.String {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var materialPickers: [Swift.String : AlterCore.MaterialPickerMetadataDefinition] {
    get
  }
  public var colorPickers: [Swift.String : AlterCore.ColorPickerMetadataDefinition] {
    get
  }
  public var libraryVariants: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String?
  public func component2() -> Swift.String
  public func component3() -> [Swift.String : Swift.String]
  public func component4() -> [Swift.String : AlterCore.MaterialPickerMetadataDefinition]
  public func component5() -> [Swift.String : AlterCore.ColorPickerMetadataDefinition]
  public func component6() -> [Swift.String : Swift.String]
  public func doCopy(_ title: Swift.String? = nil, _ thumbnailPath: Swift.String, _ tags: [Swift.String : Swift.String] = [:], _ materialPickers: [Swift.String : AlterCore.MaterialPickerMetadataDefinition] = [:], _ colorPickers: [Swift.String : AlterCore.ColorPickerMetadataDefinition] = [:], _ libraryVariants: [Swift.String : Swift.String] = [:]) -> AlterCore.ItemVariantMetadataDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemVariantMetadataDefinition
  public static func == (lhs: AlterCore.ItemVariantMetadataDefinition, rhs: AlterCore.ItemVariantMetadataDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemMetadataDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ title: Swift.String, _ tags: [Swift.String : Swift.String] = [:], _ mandatoryContainers: [Swift.String] = [], _ occupiedContainers: [Swift.String], _ definedContainers: [AlterCore.ContainerDefinition] = [], _ conflictingContainers: [Swift.String] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenders: [Swift.String] = [], _ boneBlenderPresets: [Swift.String] = [], _ variants: [AlterCore.ItemVariantMetadataDefinition])
  public var name: Swift.String {
    get
  }
  public var title: Swift.String {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var mandatoryContainers: [Swift.String] {
    get
  }
  public var occupiedContainers: [Swift.String] {
    get
  }
  public var definedContainers: [AlterCore.ContainerDefinition] {
    get
  }
  public var conflictingContainers: [Swift.String] {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var boneBlenders: [Swift.String] {
    get
  }
  public var boneBlenderPresets: [Swift.String] {
    get
  }
  public var variants: [AlterCore.ItemVariantMetadataDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.String
  public func component3() -> [Swift.String : Swift.String]
  public func component4() -> [Swift.String]
  public func component5() -> [Swift.String]
  public func component6() -> [AlterCore.ContainerDefinition]
  public func component7() -> [Swift.String]
  public func component8() -> [Swift.String : Swift.Float]
  public func component9() -> [Swift.String]
  public func component10() -> [Swift.String]
  public func component11() -> [AlterCore.ItemVariantMetadataDefinition]
  public func doCopy(_ name: Swift.String, _ title: Swift.String, _ tags: [Swift.String : Swift.String] = [:], _ mandatoryContainers: [Swift.String] = [], _ occupiedContainers: [Swift.String], _ definedContainers: [AlterCore.ContainerDefinition] = [], _ conflictingContainers: [Swift.String] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenders: [Swift.String] = [], _ boneBlenderPresets: [Swift.String] = [], _ variants: [AlterCore.ItemVariantMetadataDefinition]) -> AlterCore.ItemMetadataDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemMetadataDefinition
  public static func == (lhs: AlterCore.ItemMetadataDefinition, rhs: AlterCore.ItemMetadataDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LocaleDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ items: [Swift.String : AlterCore.ItemLocaleDefinition], _ designerLogic: AlterCore.DesignerLogicLocaleDefinition)
  public var items: [Swift.String : AlterCore.ItemLocaleDefinition] {
    get
  }
  public var designerLogic: AlterCore.DesignerLogicLocaleDefinition {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.ItemLocaleDefinition]
  public func component2() -> AlterCore.DesignerLogicLocaleDefinition
  public func doCopy(_ items: [Swift.String : AlterCore.ItemLocaleDefinition], _ designerLogic: AlterCore.DesignerLogicLocaleDefinition) -> AlterCore.LocaleDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.LocaleDefinition
  public static func == (lhs: AlterCore.LocaleDefinition, rhs: AlterCore.LocaleDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FacemojiAPIClass : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var isFullyActivated: Swift.Bool {
    get
  }
  public var isDemoMode: Swift.Bool {
    get
  }
  public func initialize(_ apiKey: Swift.String, _ context: AlterCore.ApplicationContext) -> AlterCore.Future<Swift.Bool>
  public func addDemoTimeoutCallback(_ cb: @escaping () -> Swift.Void)
  public static func == (lhs: AlterCore.FacemojiAPIClass, rhs: AlterCore.FacemojiAPIClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public var FacemojiAPI: AlterCore.FacemojiAPIClass
public enum LogLevel : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case `internal`
  case debug
  case info
  case warning
  case error
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.LogLevel, b: AlterCore.LogLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Logger : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public static var logLevel: AlterCore.LogLevel {
    get
    set(newValue)
  }
  public static var printLogWithListeners: Swift.Bool {
    get
    set(newValue)
  }
  public static func log(_ level: AlterCore.LogLevel, _ message: Swift.String, _ logStackTrace: AlterCore.KotlinException? = nil)
  public static func addLogListener(_ l: @escaping (AlterCore.LogLevel, Swift.String) -> Swift.Void)
  public static func removeLogListener(_ l: @escaping (AlterCore.LogLevel, Swift.String) -> Swift.Void)
  public static func time() -> AlterCore.TimeLogger
  public static func debug(_ message: Swift.String)
  public static func info(_ message: Swift.String)
  public static func warning(_ message: Swift.String)
  public static func error(_ message: Swift.String)
  public static func error(_ error: AlterCore.KotlinException)
  public static func error(_ message: Swift.String, _ error: AlterCore.KotlinException)
  public static func == (lhs: AlterCore.Logger, rhs: AlterCore.Logger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TimeLogger : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ start: Swift.Int64 = getTimeMillis())
  public func log(_ level: AlterCore.LogLevel, _ message: Swift.String, _ logStackTrace: AlterCore.KotlinException? = nil)
  public func debug(_ message: Swift.String)
  public func `internal`(_ message: Swift.String)
  public func info(_ message: Swift.String)
  public func warning(_ message: Swift.String)
  public func error(_ message: Swift.String)
  public static func == (lhs: AlterCore.TimeLogger, rhs: AlterCore.TimeLogger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DispatchQueue : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String)
  public static var main: AlterCore.DispatchQueue {
    get
  }
  public static var current: AlterCore.DispatchQueue? {
    get
  }
  public static var globalAsync: AlterCore.DispatchQueue {
    get
  }
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func runOrQueue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public static func createSingleThreaded(_ name: Swift.String) -> AlterCore.DispatchQueue
  public static func createSystemQueue(_ name: Swift.String) -> AlterCore.DispatchQueue
  public static func == (lhs: AlterCore.DispatchQueue, rhs: AlterCore.DispatchQueue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PeriodicExecutor : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ intervalSeconds: Swift.Double, _ fn: @escaping () -> Swift.Void)
  public func cancel()
  public static func == (lhs: AlterCore.PeriodicExecutor, rhs: AlterCore.PeriodicExecutor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Future<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public var resolved: Swift.Bool {
    get
  }
  public var currentValue: T? {
    get
  }
  public func whenDone(_ consumer: @escaping (T) -> Swift.Void)
  public func peek(_ consumer: @escaping (T) -> Swift.Void) -> AlterCore.Future<T>
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Future<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Future<U>) -> AlterCore.Future<U>
  public func waitFor() -> T
  public func waitFor(_ timeoutMillis: Swift.Int) -> T?
  @discardableResult
  public func logError<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logWarning<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logInfo<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  @discardableResult
  public func logDebug<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  public func logInternal<TExt>(_ prefix: Swift.String? = nil) -> AlterCore.Future<TExt?> where T : AlterCore.Try<TExt>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Try<U>) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Future<AlterCore.Try<U>>) -> AlterCore.Future<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> AlterCore.Try<AlterCore.Future<U>>) -> AlterCore.Future<AlterCore.Try<U>>
  public func mapError<TExt>(_ mapper: @escaping (AlterCore.KotlinException) -> AlterCore.KotlinException) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func `catch`<TExt>(_ catcher: @escaping (AlterCore.KotlinException) -> TExt) -> AlterCore.Future<TExt> where T : AlterCore.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<TExt>) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Future<AlterCore.Try<TExt>>) -> AlterCore.Future<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func upcast<SuperType>() -> AlterCore.Future<SuperType>
  public func upcastTry<SuperType, DerivedTypeExt>() -> AlterCore.Future<AlterCore.Try<SuperType>> where T : AlterCore.Try<DerivedTypeExt>
  public static func any<T>(_ futures: AlterCore.KotlinArray<AlterCore.Future<T>>) -> AlterCore.Future<T>
  public static func all<T>(_ futures: [AlterCore.Future<T>]) -> AlterCore.Future<[T]>
  public static func resolved<T>(_ value: T) -> AlterCore.Future<T>
  public static func async<T>(_ fn: @escaping () -> T) -> AlterCore.Future<T>
  public static func fromGenerator<T>(_ generator: @escaping (@escaping (T) -> Swift.Void) -> Swift.Void) -> AlterCore.Future<T>
  public static func == (lhs: AlterCore.Future<T>, rhs: AlterCore.Future<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Observable<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ generator: @escaping (@escaping (T) -> Swift.Void, @escaping () -> Swift.Void) -> Swift.Void)
  public convenience init(_ futures: AlterCore.KotlinArray<AlterCore.Future<T>>)
  public convenience init(_ futures_: Any)
  public convenience init(_ value: T)
  public var first: AlterCore.Future<T> {
    get
  }
  public var value: T? {
    get
  }
  public var last: AlterCore.Future<T?> {
    get
  }
  public var id: Swift.Int {
    get
  }
  public func subscribe(_ observer: @escaping (T) -> Swift.Void)
  public func unsubscribe(_ observer: @escaping (T) -> Swift.Void)
  public func map<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Observable<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> AlterCore.Observable<U>) -> AlterCore.Observable<U>
  public func mapNotNull<U>(_ mapper: @escaping (T) -> U?) -> AlterCore.Observable<U>
  public func peek(_ fn: @escaping (T) -> Swift.Void) -> AlterCore.Observable<T>
  public func filter(_ fn: @escaping (T) -> Swift.Bool) -> AlterCore.Observable<T>
  public func zipSecond<U>(_ withValue: U) -> AlterCore.Observable<AlterCore.KotlinPair<T, U>>
  public func zipFirst<U>(_ withValue: U) -> AlterCore.Observable<AlterCore.KotlinPair<U, T>>
  public func zipMap<U>(_ mapper: @escaping (T) -> U) -> AlterCore.Observable<AlterCore.KotlinPair<T, U>>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Try<U>) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> AlterCore.Observable<AlterCore.Try<U>>) -> AlterCore.Observable<AlterCore.Try<U>> where T : AlterCore.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> AlterCore.Try<AlterCore.Observable<U>>) -> AlterCore.Observable<AlterCore.Try<U>>
  public func `catch`<TExt>(_ catcher: @escaping (AlterCore.KotlinException) -> TExt) -> AlterCore.Observable<TExt> where T : AlterCore.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Try<TExt>) -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (AlterCore.TryError) -> AlterCore.Observable<AlterCore.Try<TExt>>) -> AlterCore.Observable<AlterCore.Try<TExt>> where T : AlterCore.Try<TExt>
  public static func any<T>(_ observables: Any) -> AlterCore.Observable<T>
  public static func all<T>(_ observables: Any) -> AlterCore.Observable<[T]>
  public static func == (lhs: AlterCore.Observable<T>, rhs: AlterCore.Observable<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PlatformRenderingSurface : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ width: Swift.Int, _ height: Swift.Int, _ drawableProvider: (() -> QuartzCore.CAMetalDrawable?)?, _ userRenderTexture: Metal.MTLTexture? = nil, _ extraTextures: [Metal.MTLTexture] = [], _ synchronizeWithUI: Swift.Bool = false, _ onRenderedDelegate: (() -> Swift.Void)? = nil)
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var userRenderTexture: Metal.MTLTexture? {
    get
  }
  public var extraTextures: [Metal.MTLTexture] {
    get
  }
  public var synchronizeWithUI: Swift.Bool {
    get
  }
  public var onRenderedDelegate: (() -> Swift.Void)? {
    get
  }
  public var aspectRatio: Swift.Float {
    get
  }
  public func withDrawable<T>(_ fn: @escaping (QuartzCore.CAMetalDrawable?, Metal.MTLTexture) -> T) -> T?
  public static func == (lhs: AlterCore.PlatformRenderingSurface, rhs: AlterCore.PlatformRenderingSurface) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Device : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ framebufferCacheCapacity: Swift.Int, _ depthTextureCacheCapacity: Swift.Int, _ pipelineCacheCapacity: Swift.Int, _ device: Metal.MTLDevice)
  public var device: Metal.MTLDevice {
    get
  }
  public static func == (lhs: AlterCore.Device, rhs: AlterCore.Device) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceConfig : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ framebufferCacheCapacity: Swift.Int, _ depthTextureCacheCapacity: Swift.Int, _ pipelineCacheCapacity: Swift.Int, _ metalDevice: Metal.MTLDevice)
  public var framebufferCacheCapacity: Swift.Int {
    get
  }
  public var depthTextureCacheCapacity: Swift.Int {
    get
  }
  public var pipelineCacheCapacity: Swift.Int {
    get
  }
  public var metalDevice: Metal.MTLDevice {
    get
  }
  public static func == (lhs: AlterCore.DeviceConfig, rhs: AlterCore.DeviceConfig) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloDeferred : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloDeferred, rhs: AlterCore.HelloDeferred) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloDeferredInstanced : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func watch()
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloDeferredInstanced, rhs: AlterCore.HelloDeferredInstanced) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloFiller : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloFiller, rhs: AlterCore.HelloFiller) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloFramebuffer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloFramebuffer, rhs: AlterCore.HelloFramebuffer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloParticles : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFileSystem: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloParticles, rhs: AlterCore.HelloParticles) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloResources : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.ResourceFileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloResources, rhs: AlterCore.HelloResources) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTexturesHotSwap : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTexturesHotSwap, rhs: AlterCore.HelloTexturesHotSwap) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTextures : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ resourceFs: AlterCore.FileSystem, _ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTextures, rhs: AlterCore.HelloTextures) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class HelloTriangle : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ deviceConfig: AlterCore.DeviceConfig)
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public static func == (lhs: AlterCore.HelloTriangle, rhs: AlterCore.HelloTriangle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RendererViewWrapper : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ view: UIKit.UIView, _ device: Metal.MTLDevice)
  public var synchronizeWithUI: Swift.Bool {
    get
    set(newValue)
  }
  public var aspectRatio: Swift.Float {
    get
  }
  public func nextDrawable(_ onFrameRendered: (() -> Swift.Void)? = nil) -> AlterCore.PlatformRenderingSurface
  public func nextDrawable(_ extraTargetTextures: [Metal.MTLTexture], _ onFrameRendered: (() -> Swift.Void)? = nil) -> AlterCore.PlatformRenderingSurface
  public func updateSize()
  public func destroy()
  public static func == (lhs: AlterCore.RendererViewWrapper, rhs: AlterCore.RendererViewWrapper) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AvatarRenderer {
  var currentAvatarAnimationData: AlterCore.AvatarAnimationData { get }
  var width: Swift.Int { get }
  var height: Swift.Int { get }
  var animations: [Swift.String] { get }
  var currentAvatarMatrix: AlterCore.AvatarMatrix? { get }
  func draw(_ surface: AlterCore.PlatformRenderingSurface)
  func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage?, _ superSampling: Swift.Float, _ flipY: Swift.Bool, _ maxPhysicsIterations: Swift.Int) -> AlterCore.Try<AlterCore.UIKitImage>
  func updateView(_ width: Swift.Int, _ height: Swift.Int)
  func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float?)
  func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float?)
  func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float?)
  func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int?, _ startDelay: Swift.Float, _ onStopListener: ((Swift.String) -> Swift.Void)?)
  func stopAnimation(_ animationName: Swift.String)
  func stopAllAnimations()
  func hideAvatar()
  func showAvatar()
  func setBackgroundColor(_ color: AlterCore.Col)
  func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  func setOverlayImageShrink(_ image: AlterCore.Image)
  func removeOverlay()
  func setAnimatedLight(_ animatedLight: Swift.Bool)
  func setDefaultSmoothing(_ smoothing: Swift.Float)
  func clone() -> AlterCore.AvatarRenderer
  func fixedZReprojector(_ artisticScale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  func fixedScaleReprojector(_ artisticScale: Swift.Float) -> AlterCore.FaceTrackerReprojector
  static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
}
@_hasMissingDesignatedInitializers public class AvatarRendererWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarRenderer {
  public var _wrappedAvatarRenderer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var currentAvatarAnimationData: AlterCore.AvatarAnimationData {
    get
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var animations: [Swift.String] {
    get
  }
  public var currentAvatarMatrix: AlterCore.AvatarMatrix? {
    get
  }
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage? = nil, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false, _ maxPhysicsIterations: Swift.Int = 1) -> AlterCore.Try<AlterCore.UIKitImage>
  public func updateView(_ width: Swift.Int, _ height: Swift.Int)
  public func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float? = nil)
  public func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float? = nil)
  public func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float? = nil)
  public func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  public func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  public func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int? = nil, _ startDelay: Swift.Float = Float(0), _ onStopListener: ((Swift.String) -> Swift.Void)? = nil)
  public func stopAnimation(_ animationName: Swift.String)
  public func stopAllAnimations()
  public func hideAvatar()
  public func showAvatar()
  public func setBackgroundColor(_ color: AlterCore.Col)
  public func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  public func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageShrink(_ image: AlterCore.Image)
  public func removeOverlay()
  public func setAnimatedLight(_ animatedLight: Swift.Bool)
  public func setDefaultSmoothing(_ smoothing: Swift.Float)
  public func clone() -> AlterCore.AvatarRenderer
  public func fixedZReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public func fixedScaleReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
}
@_hasMissingDesignatedInitializers public class Avatar : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarRenderer {
  public var _wrappedAvatarRenderer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var loader: AlterCore.AvatarLoader {
    get
  }
  public var avatarMatrix: AlterCore.AvatarMatrix? {
    get
  }
  public var strictMode: Swift.Bool {
    get
    set(newValue)
  }
  public var bundledFileSystem: AlterCore.FileSystem {
    get
  }
  public var currentAvatarAnimationData: AlterCore.AvatarAnimationData {
    get
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var animations: [Swift.String] {
    get
  }
  public var currentAvatarMatrix: AlterCore.AvatarMatrix? {
    get
  }
  public func updateAvatarFromMatrix(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func updateAvatarFromJson(_ json: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func updateAvatarFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func setFileSystem(_ fileSystem: AlterCore.FileSystem)
  public func clone() -> AlterCore.AvatarRenderer
  public func draw(_ surface: AlterCore.PlatformRenderingSurface)
  public func drawImage(_ width: Swift.Int, _ height: Swift.Int, _ reuse: AlterCore.UIKitImage? = nil, _ superSampling: Swift.Float = Float(2), _ flipY: Swift.Bool = false, _ maxPhysicsIterations: Swift.Int = 1) -> AlterCore.Try<AlterCore.UIKitImage>
  public func updateView(_ width: Swift.Int, _ height: Swift.Int)
  public func setLiveBlendshapes(_ blendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float? = nil)
  public func setAvatarPosition(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ smoothing: Swift.Float? = nil)
  public func setAvatarAnimationData(_ newData: AlterCore.AvatarAnimationData, _ smoothing: Swift.Float? = nil)
  public func applyLoadedAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  @available(*, deprecated, renamed: "applyLoadedAvatarMatrix", message: "Deprecated for semantic reasons, use applyLoadedAvatarMatrix instead")
  public func reloadAvatarMatrix(_ newMatrix: AlterCore.LoadedAvatarMatrix) -> AlterCore.Try<Swift.Void>
  public func startAnimation(_ animationName: Swift.String, _ numberOfRuns: Swift.Int? = nil, _ startDelay: Swift.Float = Float(0), _ onStopListener: ((Swift.String) -> Swift.Void)? = nil)
  public func stopAnimation(_ animationName: Swift.String)
  public func stopAllAnimations()
  public func hideAvatar()
  public func showAvatar()
  public func setBackgroundColor(_ color: AlterCore.Col)
  public func setBackgroundImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  public func setOverlayImage(_ image: AlterCore.Image, _ fillMode: AlterCore.FillMode)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setBackgroundImage", message: "Deprecated to simplify API, use setBackgroundImage instead")
  public func setBackgroundImageShrink(_ image: AlterCore.Image, _ backgroundColor: AlterCore.Col)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageStretch(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageZoom(_ image: AlterCore.Image)
  @available(*, deprecated, renamed: "setOverlayImage", message: "Deprecated to simplify API, use setOverlayImage instead")
  public func setOverlayImageShrink(_ image: AlterCore.Image)
  public func removeOverlay()
  public func setAnimatedLight(_ animatedLight: Swift.Bool)
  public func setDefaultSmoothing(_ smoothing: Swift.Float)
  public func fixedZReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public func fixedScaleReprojector(_ artisticScale: Swift.Float = Float(1.0)) -> AlterCore.FaceTrackerReprojector
  public static func create(_ avatarRendererConfig: AlterCore.AvatarRendererConfig) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>
  public static func == (lhs: AlterCore.Avatar, rhs: AlterCore.Avatar) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarFactory : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var bundledFileSystem: AlterCore.FileSystem {
    get
  }
  public var dataFileSystem: AlterCore.FileSystem {
    get
  }
  public var avatarLoader: AlterCore.AvatarLoader {
    get
  }
  public var device: AlterCore.Device {
    get
  }
  public func createEmptyAvatar() -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromMatrix(_ avatarMatrix: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromJson(_ json: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func createAvatarFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>
  public func parseAvatarMatrixFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<AlterCore.AvatarMatrix>>
  public func parseAvatarMatrixFromJson(_ json: Swift.String) -> AlterCore.Try<AlterCore.AvatarMatrix>
  public func parseAvatarMatricesFromFile(_ path: Swift.String, _ fileSystem: AlterCore.FileSystem? = nil) -> AlterCore.Future<AlterCore.Try<[AlterCore.AvatarMatrix]>>
  public func parseAvatarMatricesFromJson(_ json: Swift.String) -> AlterCore.Try<[AlterCore.AvatarMatrix]>
  public static func create(_ serverUrl: Swift.String, _ strictMode: Swift.Bool = false) -> AlterCore.Try<AlterCore.AvatarFactory>
  public static func create(_ dataFileSystem: AlterCore.FileSystem, _ strictMode: Swift.Bool = false) -> AlterCore.Try<AlterCore.AvatarFactory>
  public static func == (lhs: AlterCore.AvatarFactory, rhs: AlterCore.AvatarFactory) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationData : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ blendshapes: [Swift.String : Swift.Float], _ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var position: AlterCore.Vec3 {
    get
  }
  public var rotation: AlterCore.Quaternion {
    get
  }
  public var scale: AlterCore.Vec3 {
    get
  }
  public static var DEFAULT_AVATAR_POSITION: AlterCore.Vec3 {
    get
  }
  public static var EMPTY: AlterCore.AvatarAnimationData {
    get
  }
  public func interpolate(_ other: AlterCore.AvatarAnimationData, _ t: Swift.Float) -> AlterCore.AvatarAnimationData
  public func withBlendshapes(_ newBlendshapes: [Swift.String : Swift.Float], _ smoothing: Swift.Float) -> AlterCore.AvatarAnimationData
  public func withPosition(_ newPosition: AlterCore.Vec3, _ newRotation: AlterCore.Quaternion, _ newScale: AlterCore.Vec3, _ smoothing: Swift.Float) -> AlterCore.AvatarAnimationData
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : Swift.Float]
  public func component2() -> AlterCore.Vec3
  public func component3() -> AlterCore.Quaternion
  public func component4() -> AlterCore.Vec3
  public func doCopy(_ blendshapes: [Swift.String : Swift.Float], _ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3) -> AlterCore.AvatarAnimationData
  public static func == (lhs: AlterCore.AvatarAnimationData, rhs: AlterCore.AvatarAnimationData) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FallbackAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ mainController: AlterCore.AvatarController, _ fallbackController: AlterCore.AvatarController, _ toMainTransitionTime: Swift.Float = Float(0.5), _ toFallbackTransitionTime: Swift.Float = Float(0.5))
  public var mainController: AlterCore.AvatarController {
    get
  }
  public var fallbackController: AlterCore.AvatarController {
    get
  }
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func == (lhs: AlterCore.FallbackAvatarController, rhs: AlterCore.FallbackAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerResultAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ renderer: AlterCore.AvatarRenderer)
  public func frame() -> AlterCore.AvatarAnimationData?
  public func update(_ trackResult: AlterCore.FaceTrackerResult?)
  public static func create(_ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerResultAvatarController>>
  public static func == (lhs: AlterCore.TrackerResultAvatarController, rhs: AlterCore.TrackerResultAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ tracker: AlterCore.FaceTracker, _ renderer: AlterCore.AvatarRenderer)
  @discardableResult
  public func updateFromCamera(_ image: AlterCore.TrackerImage) -> AlterCore.FaceTrackerResult?
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func create(_ tracker: AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>, _ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
  public static func create(_ tracker: AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>, _ avatar: AlterCore.Future<AlterCore.Try<AlterCore.Avatar>>) -> AlterCore.Future<AlterCore.Try<AlterCore.TrackerAvatarController>>
  public static func == (lhs: AlterCore.TrackerAvatarController, rhs: AlterCore.TrackerAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SerializingTrackerAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ tracker: AlterCore.FaceTracker, _ renderer: AlterCore.AvatarRenderer)
  public var serializationFormat: AlterCore.KotlinByteArray {
    get
  }
  public func updateFromCamera(_ image: AlterCore.TrackerImage) -> AlterCore.KotlinByteArray?
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func create(_ tracker: AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>, _ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.SerializingTrackerAvatarController>>
  public static func == (lhs: AlterCore.SerializingTrackerAvatarController, rhs: AlterCore.SerializingTrackerAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeserializingTrackerAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ serializationFormat: AlterCore.KotlinByteArray, _ renderer: AlterCore.AvatarRenderer)
  @discardableResult
  public func update(_ serializedTrackerResult: AlterCore.KotlinByteArray?) -> AlterCore.DeserializedResult?
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func create(_ serializationFormat: AlterCore.KotlinByteArray, _ renderer: AlterCore.Future<AlterCore.Try<AlterCore.AvatarRenderer>>) -> AlterCore.Future<AlterCore.Try<AlterCore.DeserializingTrackerAvatarController>>
  public static func == (lhs: AlterCore.DeserializingTrackerAvatarController, rhs: AlterCore.DeserializingTrackerAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AnimatingAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ definition: AlterCore.AvatarAnimationDefinition)
  public func frame() -> AlterCore.AvatarAnimationData?
  public static func == (lhs: AlterCore.AnimatingAvatarController, rhs: AlterCore.AnimatingAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class InteractiveAvatarController : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.AvatarController {
  public var _wrappedAvatarController: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ renderer: AlterCore.AvatarRenderer, _ startingPosition: AlterCore.AvatarAnimationData)
  public func frame() -> AlterCore.AvatarAnimationData?
  public func move(_ x: Swift.Float, _ y: Swift.Float)
  public func move(_ delta: AlterCore.Vec2)
  public func rotate(_ x: Swift.Float, _ y: Swift.Float)
  public func rotate(_ delta: AlterCore.Vec2)
  public func scale(_ x: Swift.Float, _ y: Swift.Float)
  public func scale(_ delta: AlterCore.Vec2)
  public static func == (lhs: AlterCore.InteractiveAvatarController, rhs: AlterCore.InteractiveAvatarController) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarLoader : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device)
  public convenience init(_ fileSystem: AlterCore.FileSystem, _ device: AlterCore.Device, _ cacheJsons: Swift.Bool, _ cacheModels: Swift.Bool, _ cacheTextures: Swift.Bool)
  public convenience init(_ device: AlterCore.Device, _ serverUrl: Swift.String, _ context: AlterCore.ApplicationContext, _ cacheJsons: Swift.Bool, _ cacheModels: Swift.Bool, _ cacheTextures: Swift.Bool)
  public convenience init(_ device: AlterCore.Device, _ serverUrl: Swift.String, _ context: AlterCore.ApplicationContext)
  public var fileSystem: AlterCore.FileSystem {
    get
  }
  public var strictMode: Swift.Bool {
    get
  }
  public func withFileSystem(_ fileSystem: AlterCore.FileSystem) -> AlterCore.AvatarLoader
  public func withStrictMode(_ mode: Swift.Bool) -> AlterCore.AvatarLoader
  public func loadAvatarMatrix(_ fileSystem: AlterCore.FileSystem, _ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ path: AlterCore.Path) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ matrix: Swift.String) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public func loadAvatarMatrix(_ matrix_: AlterCore.AvatarMatrix) -> AlterCore.Future<AlterCore.Try<AlterCore.LoadedAvatarMatrix>>
  public static func parseAvatarMatrices(_ matricesJson: Swift.String) -> AlterCore.Try<[AlterCore.AvatarMatrix]>
  public static func parseAvatarMatrix(_ matrixJson: Swift.String) -> AlterCore.Try<AlterCore.AvatarMatrix>
  public static func == (lhs: AlterCore.AvatarLoader, rhs: AlterCore.AvatarLoader) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarRendererConfig : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var device: AlterCore.Device {
    get
  }
  public var context: AlterCore.ApplicationContext {
    get
  }
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public static func create(_ width: Swift.Int, _ height: Swift.Int, _ metalDevice: Metal.MTLDevice) -> AlterCore.Try<AlterCore.AvatarRendererConfig>
  public static func createDefault() -> AlterCore.Try<AlterCore.AvatarRendererConfig>
  public static func == (lhs: AlterCore.AvatarRendererConfig, rhs: AlterCore.AvatarRendererConfig) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol AvatarViewInterface {
  var avatar: AlterCore.Avatar? { get set }
  var avatarController: AlterCore.AvatarController? { get set }
  func setOnFrameListener(_ onFrame: @escaping (Swift.Float) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class AvatarViewInterfaceWrapper : AlterCore.ConvertibleToKotlin, AlterCore.AvatarViewInterface {
  public var _wrappedAvatarViewInterface: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var avatar: AlterCore.Avatar? {
    get
    set(newValue)
  }
  public var avatarController: AlterCore.AvatarController? {
    get
    set(newValue)
  }
  public func setOnFrameListener(_ onFrame: @escaping (Swift.Float) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class AnimationDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ offsetStartInSeconds: Swift.Float? = nil, _ durationInSeconds: Swift.Float? = nil, _ hiddenWhenNotPlaying: Swift.Bool = true, _ numberOfRuns: Swift.Int = 1)
  public var offsetStartInSeconds: Swift.Float? {
    get
  }
  public var durationInSeconds: Swift.Float? {
    get
  }
  public var hiddenWhenNotPlaying: Swift.Bool {
    get
  }
  public var numberOfRuns: Swift.Int {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AnimationDefinition
  public static func == (lhs: AlterCore.AnimationDefinition, rhs: AlterCore.AnimationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationFrame : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ timeSeconds: Swift.Float, _ blendshapes: [Swift.String : Swift.Float] = [:], _ transform: AlterCore.TransformDefinition = TransformDefinition())
  public var timeSeconds: Swift.Float {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var transform: AlterCore.TransformDefinition {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarAnimationFrame
  public static func == (lhs: AlterCore.AvatarAnimationFrame, rhs: AlterCore.AvatarAnimationFrame) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarAnimationDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ repeats: Swift.Int = 0, _ timesAreCumulative: Swift.Bool = false, _ frames: [AlterCore.AvatarAnimationFrame] = [])
  public var repeats: Swift.Int {
    get
  }
  public var timesAreCumulative: Swift.Bool {
    get
  }
  public var frames: [AlterCore.AvatarAnimationFrame] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarAnimationDefinition
  public static func == (lhs: AlterCore.AvatarAnimationDefinition, rhs: AlterCore.AvatarAnimationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AvatarMatrix : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String? = nil, _ items: [AlterCore.ItemReferenceDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenderPresetWeights: [Swift.String : Swift.Float] = [:], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:])
  public var name: Swift.String? {
    get
  }
  public var items: [AlterCore.ItemReferenceDefinition] {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var boneBlenderPresetWeights: [Swift.String : Swift.Float] {
    get
  }
  public var boneBlenderWeights: [Swift.String : Swift.Float] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String?
  public func component2() -> [AlterCore.ItemReferenceDefinition]
  public func component3() -> [Swift.String : Swift.Float]
  public func component4() -> [Swift.String : Swift.Float]
  public func component5() -> [Swift.String : Swift.Float]
  public func doCopy(_ name: Swift.String? = nil, _ items: [AlterCore.ItemReferenceDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:], _ boneBlenderPresetWeights: [Swift.String : Swift.Float] = [:], _ boneBlenderWeights: [Swift.String : Swift.Float] = [:]) -> AlterCore.AvatarMatrix
  public func addBoneBlenderWeights(_ boneBlenderWeights: [Swift.String : Swift.Float]) -> AlterCore.AvatarMatrix
  public func addBoneBlenderPresetWeights(_ boneBlenderPresetWeights: [Swift.String : Swift.Float]) -> AlterCore.AvatarMatrix
  public func boneBlenders(_ fileSystem: AlterCore.FileSystem, _ itemRange: AlterCore.KotlinIntRange) -> AlterCore.Future<AlterCore.Try<Swift.Set<Swift.String>>>
  public func toJson() -> Swift.String
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.AvatarMatrix
  public static func == (lhs: AlterCore.AvatarMatrix, rhs: AlterCore.AvatarMatrix) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BlendshapeBoneConversionDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ weight: AlterCore.ComputationDefinition, _ transform: AlterCore.TransformDefinition)
  public var weight: AlterCore.ComputationDefinition {
    get
  }
  public var transform: AlterCore.TransformDefinition {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.ComputationDefinition
  public func component2() -> AlterCore.TransformDefinition
  public func doCopy(_ weight: AlterCore.ComputationDefinition, _ transform: AlterCore.TransformDefinition) -> AlterCore.BlendshapeBoneConversionDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.BlendshapeBoneConversionDefinition
  public static func == (lhs: AlterCore.BlendshapeBoneConversionDefinition, rhs: AlterCore.BlendshapeBoneConversionDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BoneAdjustmentDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ index: Swift.Int? = nil, _ uv: [Swift.Float] = [], _ position: [Swift.Float] = [], _ material: Swift.String? = nil, _ scaleWithBlendshapes: [Swift.String] = [], _ addNew: AlterCore.BoneDefinition? = nil)
  public var index: Swift.Int? {
    get
  }
  public var uv: [Swift.Float] {
    get
  }
  public var position: [Swift.Float] {
    get
  }
  public var material: Swift.String? {
    get
  }
  public var scaleWithBlendshapes: [Swift.String] {
    get
  }
  public var addNew: AlterCore.BoneDefinition? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.Int?
  public func component2() -> [Swift.Float]
  public func component3() -> [Swift.Float]
  public func component4() -> Swift.String?
  public func component5() -> [Swift.String]
  public func component6() -> AlterCore.BoneDefinition?
  public func doCopy(_ index: Swift.Int? = nil, _ uv: [Swift.Float] = [], _ position: [Swift.Float] = [], _ material: Swift.String? = nil, _ scaleWithBlendshapes: [Swift.String] = [], _ addNew: AlterCore.BoneDefinition? = nil) -> AlterCore.BoneAdjustmentDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.BoneAdjustmentDefinition
  public static func == (lhs: AlterCore.BoneAdjustmentDefinition, rhs: AlterCore.BoneAdjustmentDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BlendingTransformsDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ transform0: AlterCore.TransformDefinition, _ tags0: [Swift.String : Swift.String] = [:], _ transform1: AlterCore.TransformDefinition, _ tags1: [Swift.String : Swift.String] = [:])
  public var transform0: AlterCore.TransformDefinition {
    get
  }
  public var tags0: [Swift.String : Swift.String] {
    get
  }
  public var transform1: AlterCore.TransformDefinition {
    get
  }
  public var tags1: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.TransformDefinition
  public func component2() -> [Swift.String : Swift.String]
  public func component3() -> AlterCore.TransformDefinition
  public func component4() -> [Swift.String : Swift.String]
  public func doCopy(_ transform0: AlterCore.TransformDefinition, _ tags0: [Swift.String : Swift.String] = [:], _ transform1: AlterCore.TransformDefinition, _ tags1: [Swift.String : Swift.String] = [:]) -> AlterCore.BlendingTransformsDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.BlendingTransformsDefinition
  public static func == (lhs: AlterCore.BlendingTransformsDefinition, rhs: AlterCore.BlendingTransformsDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BoneBlenderDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ bones: [Swift.String : AlterCore.BlendingTransformsDefinition])
  public var bones: [Swift.String : AlterCore.BlendingTransformsDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.BlendingTransformsDefinition]
  public func doCopy(_ bones: [Swift.String : AlterCore.BlendingTransformsDefinition]) -> AlterCore.BoneBlenderDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.BoneBlenderDefinition
  public static func == (lhs: AlterCore.BoneBlenderDefinition, rhs: AlterCore.BoneBlenderDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BoneDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ parent: Swift.String, _ transform: AlterCore.TransformDefinition)
  public var parent: Swift.String {
    get
  }
  public var transform: AlterCore.TransformDefinition {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.BoneDefinition
  public static func == (lhs: AlterCore.BoneDefinition, rhs: AlterCore.BoneDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ComputationDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ take: Swift.String, _ args: [AlterCore.ComputationDefinition] = [], _ scale: Swift.Float = Float(1), _ bias: Swift.Float = Float(0), _ min: Swift.Float? = Float(0), _ max: Swift.Float? = Float(1))
  public var take: Swift.String {
    get
  }
  public var args: [AlterCore.ComputationDefinition] {
    get
  }
  public var scale: Swift.Float {
    get
  }
  public var bias: Swift.Float {
    get
  }
  public var min: Swift.Float? {
    get
  }
  public var max: Swift.Float? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [AlterCore.ComputationDefinition]
  public func component3() -> Swift.Float
  public func component4() -> Swift.Float
  public func component5() -> Swift.Float?
  public func component6() -> Swift.Float?
  public func doCopy(_ take: Swift.String, _ args: [AlterCore.ComputationDefinition] = [], _ scale: Swift.Float = Float(1), _ bias: Swift.Float = Float(0), _ min: Swift.Float? = Float(0), _ max: Swift.Float? = Float(1)) -> AlterCore.ComputationDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ComputationDefinition
  public static func == (lhs: AlterCore.ComputationDefinition, rhs: AlterCore.ComputationDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ContainerDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ targetBoneName: Swift.String? = nil, _ renderingOrder: Swift.Int? = nil, _ itemLimit: Swift.Int? = nil, _ conflictingBlendshapes: [Swift.String] = [])
  public var name: Swift.String {
    get
  }
  public var targetBoneName: Swift.String? {
    get
  }
  public var renderingOrder: Swift.Int? {
    get
  }
  public var itemLimit: Swift.Int? {
    get
  }
  public var conflictingBlendshapes: [Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.String?
  public func component3() -> Swift.Int?
  public func component4() -> Swift.Int?
  public func component5() -> [Swift.String]
  public func doCopy(_ name: Swift.String, _ targetBoneName: Swift.String? = nil, _ renderingOrder: Swift.Int? = nil, _ itemLimit: Swift.Int? = nil, _ conflictingBlendshapes: [Swift.String] = []) -> AlterCore.ContainerDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ContainerDefinition
  public static func == (lhs: AlterCore.ContainerDefinition, rhs: AlterCore.ContainerDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String, _ tags: [Swift.String : Swift.String], _ description: Swift.String? = nil, _ mandatoryContainers: [Swift.String] = [], _ parts: [AlterCore.ItemPartDefinition], _ conflictingContainers: [Swift.String] = [], _ palettes: [Swift.String : AlterCore.PaletteReferenceDefinition] = [:], _ animation: AlterCore.AnimationDefinition? = nil)
  public var title: Swift.String {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var description_: Swift.String? {
    get
  }
  public var mandatoryContainers: [Swift.String] {
    get
  }
  public var parts: [AlterCore.ItemPartDefinition] {
    get
  }
  public var conflictingContainers: [Swift.String] {
    get
  }
  public var palettes: [Swift.String : AlterCore.PaletteReferenceDefinition] {
    get
  }
  public var animation: AlterCore.AnimationDefinition? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [Swift.String : Swift.String]
  public func component3() -> Swift.String?
  public func component4() -> [Swift.String]
  public func component5() -> [AlterCore.ItemPartDefinition]
  public func component6() -> [Swift.String]
  public func component7() -> [Swift.String : AlterCore.PaletteReferenceDefinition]
  public func component8() -> AlterCore.AnimationDefinition?
  public func doCopy(_ title: Swift.String, _ tags: [Swift.String : Swift.String], _ description: Swift.String? = nil, _ mandatoryContainers: [Swift.String] = [], _ parts: [AlterCore.ItemPartDefinition], _ conflictingContainers: [Swift.String] = [], _ palettes: [Swift.String : AlterCore.PaletteReferenceDefinition] = [:], _ animation: AlterCore.AnimationDefinition? = nil) -> AlterCore.ItemDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemDefinition
  public static func == (lhs: AlterCore.ItemDefinition, rhs: AlterCore.ItemDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemLocaleDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String, _ materialLibraryVariantTitles: [Swift.String : Swift.String] = [:], _ materialTitles: [Swift.String : Swift.String] = [:], _ paletteTitles: [Swift.String : Swift.String] = [:])
  public var title: Swift.String {
    get
  }
  public var materialLibraryVariantTitles: [Swift.String : Swift.String] {
    get
  }
  public var materialTitles: [Swift.String : Swift.String] {
    get
  }
  public var paletteTitles: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [Swift.String : Swift.String]
  public func component3() -> [Swift.String : Swift.String]
  public func component4() -> [Swift.String : Swift.String]
  public func doCopy(_ title: Swift.String, _ materialLibraryVariantTitles: [Swift.String : Swift.String] = [:], _ materialTitles: [Swift.String : Swift.String] = [:], _ paletteTitles: [Swift.String : Swift.String] = [:]) -> AlterCore.ItemLocaleDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemLocaleDefinition
  public static func == (lhs: AlterCore.ItemLocaleDefinition, rhs: AlterCore.ItemLocaleDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemPartDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ container: Swift.String, _ modelConfigPath: Swift.String? = nil, _ renderingName: Swift.String? = nil, _ materialLibraryConfig: Swift.String? = nil, _ materialLibraryPropertyName: Swift.String? = nil, _ materials: [AlterCore.MaterialDefinition] = [], _ materialOverrides: [AlterCore.MaterialDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:])
  public var container: Swift.String {
    get
  }
  public var modelConfigPath: Swift.String? {
    get
  }
  public var renderingName: Swift.String? {
    get
  }
  public var materialLibraryConfig: Swift.String? {
    get
  }
  public var materialLibraryPropertyName: Swift.String? {
    get
  }
  public var materials: [AlterCore.MaterialDefinition] {
    get
  }
  public var materialOverrides: [AlterCore.MaterialDefinition] {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> Swift.String?
  public func component3() -> Swift.String?
  public func component4() -> Swift.String?
  public func component5() -> Swift.String?
  public func component6() -> [AlterCore.MaterialDefinition]
  public func component7() -> [AlterCore.MaterialDefinition]
  public func component8() -> [Swift.String : Swift.Float]
  public func doCopy(_ container: Swift.String, _ modelConfigPath: Swift.String? = nil, _ renderingName: Swift.String? = nil, _ materialLibraryConfig: Swift.String? = nil, _ materialLibraryPropertyName: Swift.String? = nil, _ materials: [AlterCore.MaterialDefinition] = [], _ materialOverrides: [AlterCore.MaterialDefinition] = [], _ blendshapes: [Swift.String : Swift.Float] = [:]) -> AlterCore.ItemPartDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemPartDefinition
  public static func == (lhs: AlterCore.ItemPartDefinition, rhs: AlterCore.ItemPartDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ItemReferenceDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ properties: [Swift.String : Swift.String] = [:])
  public var name: Swift.String {
    get
  }
  public var properties: [Swift.String : Swift.String] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [Swift.String : Swift.String]
  public func doCopy(_ name: Swift.String, _ properties: [Swift.String : Swift.String] = [:]) -> AlterCore.ItemReferenceDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ItemReferenceDefinition
  public static func == (lhs: AlterCore.ItemReferenceDefinition, rhs: AlterCore.ItemReferenceDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialProperty<T> : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ texture: Swift.String? = nil, _ value: T? = nil, _ propertyName: Swift.String? = nil)
  public var texture: Swift.String? {
    get
  }
  public var value: T? {
    get
  }
  public var propertyName: Swift.String? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String?
  public func component2() -> T?
  public func component3() -> Swift.String?
  public func doCopy(_ texture: Swift.String? = nil, _ value: T? = nil, _ propertyName: Swift.String? = nil) -> AlterCore.MaterialProperty<T>
  public static func serializer<T0, TKotlinx_serialization_coreKSerializer>(_ typeSerial0: TKotlinx_serialization_coreKSerializer) -> TKotlinx_serialization_coreKSerializer where T0 == TKotlinx_serialization_coreKSerializer.T, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  public static func serializer<TKotlinx_serialization_coreKSerializer>(_ typeParamsSerializers: AlterCore.KotlinArray<TKotlinx_serialization_coreKSerializer>) -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public static func == (lhs: AlterCore.MaterialProperty<T>, rhs: AlterCore.MaterialProperty<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ targetMaterialName: Swift.String? = nil, _ materialVariantsConfig: Swift.String? = nil, _ materialVariantsPropertyName: Swift.String? = nil, _ propertyRenames: [Swift.String : Swift.String] = [:], _ diffuse: AlterCore.MaterialProperty<Swift.String>? = nil, _ roughness: AlterCore.MaterialProperty<Swift.Float>? = nil, _ metalness: AlterCore.MaterialProperty<Swift.Float>? = nil, _ transparency: AlterCore.MaterialProperty<Swift.Float>? = nil, _ normalTexture: Swift.String? = nil, _ environmentTexture: Swift.String? = nil, _ environmentTextureImportant: Swift.Bool = false, _ brightness: Swift.Float? = nil, _ useShading: Swift.Bool? = nil, _ readsDepth: Swift.Bool? = nil, _ writesDepth: Swift.Bool? = nil, _ renderingOrder: Swift.Int? = nil, _ doubleSided: Swift.Bool? = nil, _ layers: [AlterCore.MaterialLayerDefinition] = [])
  public var targetMaterialName: Swift.String? {
    get
  }
  public var materialVariantsConfig: Swift.String? {
    get
  }
  public var materialVariantsPropertyName: Swift.String? {
    get
  }
  public var propertyRenames: [Swift.String : Swift.String] {
    get
  }
  public var diffuse: AlterCore.MaterialProperty<Swift.String>? {
    get
  }
  public var roughness: AlterCore.MaterialProperty<Swift.Float>? {
    get
  }
  public var metalness: AlterCore.MaterialProperty<Swift.Float>? {
    get
  }
  public var transparency: AlterCore.MaterialProperty<Swift.Float>? {
    get
  }
  public var normalTexture: Swift.String? {
    get
  }
  public var environmentTexture: Swift.String? {
    get
  }
  public var environmentTextureImportant: Swift.Bool {
    get
  }
  public var brightness: Swift.Float? {
    get
  }
  public var useShading: Swift.Bool? {
    get
  }
  public var readsDepth: Swift.Bool? {
    get
  }
  public var writesDepth: Swift.Bool? {
    get
  }
  public var renderingOrder: Swift.Int? {
    get
  }
  public var doubleSided: Swift.Bool? {
    get
  }
  public var layers: [AlterCore.MaterialLayerDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String?
  public func component2() -> Swift.String?
  public func component3() -> Swift.String?
  public func component4() -> [Swift.String : Swift.String]
  public func component5() -> AlterCore.MaterialProperty<Swift.String>?
  public func component6() -> AlterCore.MaterialProperty<Swift.Float>?
  public func component7() -> AlterCore.MaterialProperty<Swift.Float>?
  public func component8() -> AlterCore.MaterialProperty<Swift.Float>?
  public func component9() -> Swift.String?
  public func component10() -> Swift.String?
  public func component11() -> Swift.Bool
  public func component12() -> Swift.Float?
  public func component13() -> Swift.Bool?
  public func component14() -> Swift.Bool?
  public func component15() -> Swift.Bool?
  public func component16() -> Swift.Int?
  public func component17() -> Swift.Bool?
  public func component18() -> [AlterCore.MaterialLayerDefinition]
  public func doCopy(_ targetMaterialName: Swift.String? = nil, _ materialVariantsConfig: Swift.String? = nil, _ materialVariantsPropertyName: Swift.String? = nil, _ propertyRenames: [Swift.String : Swift.String] = [:], _ diffuse: AlterCore.MaterialProperty<Swift.String>? = nil, _ roughness: AlterCore.MaterialProperty<Swift.Float>? = nil, _ metalness: AlterCore.MaterialProperty<Swift.Float>? = nil, _ transparency: AlterCore.MaterialProperty<Swift.Float>? = nil, _ normalTexture: Swift.String? = nil, _ environmentTexture: Swift.String? = nil, _ environmentTextureImportant: Swift.Bool = false, _ brightness: Swift.Float? = nil, _ useShading: Swift.Bool? = nil, _ readsDepth: Swift.Bool? = nil, _ writesDepth: Swift.Bool? = nil, _ renderingOrder: Swift.Int? = nil, _ doubleSided: Swift.Bool? = nil, _ layers: [AlterCore.MaterialLayerDefinition] = []) -> AlterCore.MaterialDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialDefinition
  public static func == (lhs: AlterCore.MaterialDefinition, rhs: AlterCore.MaterialDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialLayerDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ name: Swift.String, _ diffuse: AlterCore.MaterialLayerProperty<Swift.String>? = nil, _ roughness: AlterCore.MaterialLayerProperty<Swift.Float>? = nil, _ metalness: AlterCore.MaterialLayerProperty<Swift.Float>? = nil, _ normal: AlterCore.MaterialLayerProperty<Swift.String>? = nil, _ transparency: AlterCore.MaterialLayerProperty<Swift.Float>? = nil)
  public var name: Swift.String {
    get
  }
  public var diffuse: AlterCore.MaterialLayerProperty<Swift.String>? {
    get
  }
  public var roughness: AlterCore.MaterialLayerProperty<Swift.Float>? {
    get
  }
  public var metalness: AlterCore.MaterialLayerProperty<Swift.Float>? {
    get
  }
  public var normal: AlterCore.MaterialLayerProperty<Swift.String>? {
    get
  }
  public var transparency: AlterCore.MaterialLayerProperty<Swift.Float>? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> AlterCore.MaterialLayerProperty<Swift.String>?
  public func component3() -> AlterCore.MaterialLayerProperty<Swift.Float>?
  public func component4() -> AlterCore.MaterialLayerProperty<Swift.Float>?
  public func component5() -> AlterCore.MaterialLayerProperty<Swift.String>?
  public func component6() -> AlterCore.MaterialLayerProperty<Swift.Float>?
  public func doCopy(_ name: Swift.String, _ diffuse: AlterCore.MaterialLayerProperty<Swift.String>? = nil, _ roughness: AlterCore.MaterialLayerProperty<Swift.Float>? = nil, _ metalness: AlterCore.MaterialLayerProperty<Swift.Float>? = nil, _ normal: AlterCore.MaterialLayerProperty<Swift.String>? = nil, _ transparency: AlterCore.MaterialLayerProperty<Swift.Float>? = nil) -> AlterCore.MaterialLayerDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialLayerDefinition
  public static func == (lhs: AlterCore.MaterialLayerDefinition, rhs: AlterCore.MaterialLayerDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialLayerProperty<T> : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ property: AlterCore.MaterialProperty<T>, _ mask: Swift.String? = nil, _ blendMode: Swift.String? = nil, _ invertProperty: Swift.Bool? = nil)
  public var property: AlterCore.MaterialProperty<T> {
    get
  }
  public var mask: Swift.String? {
    get
  }
  public var blendMode: Swift.String? {
    get
  }
  public var invertProperty: Swift.Bool? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> AlterCore.MaterialProperty<T>
  public func component2() -> Swift.String?
  public func component3() -> Swift.String?
  public func component4() -> Swift.Bool?
  public func doCopy(_ property: AlterCore.MaterialProperty<T>, _ mask: Swift.String? = nil, _ blendMode: Swift.String? = nil, _ invertProperty: Swift.Bool? = nil) -> AlterCore.MaterialLayerProperty<T>
  public static func serializer<T0, TKotlinx_serialization_coreKSerializer>(_ typeSerial0: TKotlinx_serialization_coreKSerializer) -> TKotlinx_serialization_coreKSerializer where T0 == TKotlinx_serialization_coreKSerializer.T, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  public static func serializer<TKotlinx_serialization_coreKSerializer>(_ typeParamsSerializers: AlterCore.KotlinArray<TKotlinx_serialization_coreKSerializer>) -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public static func == (lhs: AlterCore.MaterialLayerProperty<T>, rhs: AlterCore.MaterialLayerProperty<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialLibraryItemDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String? = nil, _ tags: [Swift.String : Swift.String] = [:], _ description: Swift.String? = nil, _ materials: [AlterCore.MaterialDefinition] = [], _ materialOverrides: [AlterCore.MaterialDefinition] = [], _ properties: [Swift.String : Swift.String] = [:], _ allowCustomizations: Swift.Bool = true, _ palettes: [Swift.String : AlterCore.PaletteReferenceDefinition] = [:])
  public var title: Swift.String? {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var description_: Swift.String? {
    get
  }
  public var materials: [AlterCore.MaterialDefinition] {
    get
  }
  public var materialOverrides: [AlterCore.MaterialDefinition] {
    get
  }
  public var properties: [Swift.String : Swift.String] {
    get
  }
  public var allowCustomizations: Swift.Bool {
    get
  }
  public var palettes: [Swift.String : AlterCore.PaletteReferenceDefinition] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialLibraryItemDefinition
  public static func == (lhs: AlterCore.MaterialLibraryItemDefinition, rhs: AlterCore.MaterialLibraryItemDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialLibraryDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ variants: [Swift.String : AlterCore.MaterialLibraryItemDefinition])
  public var variants: [Swift.String : AlterCore.MaterialLibraryItemDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.MaterialLibraryItemDefinition]
  public func doCopy(_ variants: [Swift.String : AlterCore.MaterialLibraryItemDefinition]) -> AlterCore.MaterialLibraryDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialLibraryDefinition
  public static func == (lhs: AlterCore.MaterialLibraryDefinition, rhs: AlterCore.MaterialLibraryDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SingleMaterialVariantDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String? = nil, _ tags: [Swift.String : Swift.String] = [:], _ description: Swift.String? = nil, _ material: AlterCore.MaterialDefinition)
  public var title: Swift.String? {
    get
  }
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var description_: Swift.String? {
    get
  }
  public var material: AlterCore.MaterialDefinition {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.SingleMaterialVariantDefinition
  public static func == (lhs: AlterCore.SingleMaterialVariantDefinition, rhs: AlterCore.SingleMaterialVariantDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class MaterialVariantsDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ variants: [Swift.String : AlterCore.SingleMaterialVariantDefinition])
  public var variants: [Swift.String : AlterCore.SingleMaterialVariantDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.String : AlterCore.SingleMaterialVariantDefinition]
  public func doCopy(_ variants: [Swift.String : AlterCore.SingleMaterialVariantDefinition]) -> AlterCore.MaterialVariantsDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.MaterialVariantsDefinition
  public static func == (lhs: AlterCore.MaterialVariantsDefinition, rhs: AlterCore.MaterialVariantsDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ModelDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ modelPath: Swift.String, _ boneAdjustments: [Swift.String : AlterCore.BoneAdjustmentDefinition] = [:], _ blendshapeConversions: [Swift.String : AlterCore.ComputationDefinition] = [:], _ blendshapeBoneConversions: [Swift.String : [AlterCore.BlendshapeBoneConversionDefinition]] = [:], _ boneBlenders: [Swift.String : AlterCore.BoneBlenderDefinition] = [:], _ boneBlenderPresets: [Swift.String : [Swift.String : Swift.Float]] = [:], _ bonePhysics: [Swift.String : AlterCore.PhysicsDefinition] = [:], _ collider: AlterCore.ColliderDefinition? = nil, _ linkBones: [Swift.String : Swift.String] = [:], _ containers: [AlterCore.ContainerDefinition] = [])
  public var modelPath: Swift.String {
    get
  }
  public var boneAdjustments: [Swift.String : AlterCore.BoneAdjustmentDefinition] {
    get
  }
  public var blendshapeConversions: [Swift.String : AlterCore.ComputationDefinition] {
    get
  }
  public var blendshapeBoneConversions: [Swift.String : [AlterCore.BlendshapeBoneConversionDefinition]] {
    get
  }
  public var boneBlenders: [Swift.String : AlterCore.BoneBlenderDefinition] {
    get
  }
  public var boneBlenderPresets: [Swift.String : [Swift.String : Swift.Float]] {
    get
  }
  public var bonePhysics: [Swift.String : AlterCore.PhysicsDefinition] {
    get
  }
  public var collider: AlterCore.ColliderDefinition? {
    get
  }
  public var linkBones: [Swift.String : Swift.String] {
    get
  }
  public var containers: [AlterCore.ContainerDefinition] {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.String
  public func component2() -> [Swift.String : AlterCore.BoneAdjustmentDefinition]
  public func component3() -> [Swift.String : AlterCore.ComputationDefinition]
  public func component4() -> [Swift.String : [AlterCore.BlendshapeBoneConversionDefinition]]
  public func component5() -> [Swift.String : AlterCore.BoneBlenderDefinition]
  public func component6() -> [Swift.String : [Swift.String : Swift.Float]]
  public func component7() -> [Swift.String : AlterCore.PhysicsDefinition]
  public func component8() -> AlterCore.ColliderDefinition?
  public func component9() -> [Swift.String : Swift.String]
  public func component10() -> [AlterCore.ContainerDefinition]
  public func doCopy(_ modelPath: Swift.String, _ boneAdjustments: [Swift.String : AlterCore.BoneAdjustmentDefinition] = [:], _ blendshapeConversions: [Swift.String : AlterCore.ComputationDefinition] = [:], _ blendshapeBoneConversions: [Swift.String : [AlterCore.BlendshapeBoneConversionDefinition]] = [:], _ boneBlenders: [Swift.String : AlterCore.BoneBlenderDefinition] = [:], _ boneBlenderPresets: [Swift.String : [Swift.String : Swift.Float]] = [:], _ bonePhysics: [Swift.String : AlterCore.PhysicsDefinition] = [:], _ collider: AlterCore.ColliderDefinition? = nil, _ linkBones: [Swift.String : Swift.String] = [:], _ containers: [AlterCore.ContainerDefinition] = []) -> AlterCore.ModelDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ModelDefinition
  public static func == (lhs: AlterCore.ModelDefinition, rhs: AlterCore.ModelDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PaletteVariantDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ tags: [Swift.String : Swift.String] = [:], _ values: [Swift.String : Swift.String])
  public var tags: [Swift.String : Swift.String] {
    get
  }
  public var values: [Swift.String : Swift.String] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.PaletteVariantDefinition
  public static func == (lhs: AlterCore.PaletteVariantDefinition, rhs: AlterCore.PaletteVariantDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PaletteDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ title: Swift.String, _ names: Swift.Set<Swift.String>, _ variants: [AlterCore.PaletteVariantDefinition])
  public var title: Swift.String {
    get
  }
  public var names: Swift.Set<Swift.String> {
    get
  }
  public var variants: [AlterCore.PaletteVariantDefinition] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.PaletteDefinition
  public static func == (lhs: AlterCore.PaletteDefinition, rhs: AlterCore.PaletteDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PaletteReferenceDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ paletteConfig: Swift.String, _ propertiesToPaletteValues: [Swift.String : Swift.String])
  public var paletteConfig: Swift.String {
    get
  }
  public var propertiesToPaletteValues: [Swift.String : Swift.String] {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.PaletteReferenceDefinition
  public static func == (lhs: AlterCore.PaletteReferenceDefinition, rhs: AlterCore.PaletteReferenceDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PhysicsDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ gravity: Swift.Float = Float(0.001), _ collisionRadius: Swift.Float = Float(0.001), _ stiffness: Swift.Float = Float(0), _ angleLimit: Swift.Float = Float(180), _ hingeAxis: [Swift.Float]? = nil, _ conflictingBlendshapes: [Swift.String] = [], _ enabled: Swift.Bool = true, _ passToChildren: Swift.Bool = true)
  public var gravity: Swift.Float {
    get
  }
  public var collisionRadius: Swift.Float {
    get
  }
  public var stiffness: Swift.Float {
    get
  }
  public var angleLimit: Swift.Float {
    get
  }
  public var hingeAxis: [Swift.Float]? {
    get
  }
  public var conflictingBlendshapes: [Swift.String] {
    get
  }
  public var enabled: Swift.Bool {
    get
  }
  public var passToChildren: Swift.Bool {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> Swift.Float
  public func component2() -> Swift.Float
  public func component3() -> Swift.Float
  public func component4() -> Swift.Float
  public func component5() -> [Swift.Float]?
  public func component6() -> [Swift.String]
  public func component7() -> Swift.Bool
  public func component8() -> Swift.Bool
  public func doCopy(_ gravity: Swift.Float = Float(0.001), _ collisionRadius: Swift.Float = Float(0.001), _ stiffness: Swift.Float = Float(0), _ angleLimit: Swift.Float = Float(180), _ hingeAxis: [Swift.Float]? = nil, _ conflictingBlendshapes: [Swift.String] = [], _ enabled: Swift.Bool = true, _ passToChildren: Swift.Bool = true) -> AlterCore.PhysicsDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.PhysicsDefinition
  public static func == (lhs: AlterCore.PhysicsDefinition, rhs: AlterCore.PhysicsDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ColliderSphereDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ sphere: [Swift.Float], _ bone: Swift.String)
  public var sphere: [Swift.Float] {
    get
  }
  public var bone: Swift.String {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.Float]
  public func component2() -> Swift.String
  public func doCopy(_ sphere: [Swift.Float], _ bone: Swift.String) -> AlterCore.ColliderSphereDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ColliderSphereDefinition
  public static func == (lhs: AlterCore.ColliderSphereDefinition, rhs: AlterCore.ColliderSphereDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public enum ColliderTopology : Swift.CustomStringConvertible, AlterCore.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case lineList
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: AlterCore.ColliderTopology, b: AlterCore.ColliderTopology) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ColliderDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ spheres: [AlterCore.ColliderSphereDefinition], _ indices: [Swift.Int], _ topology: AlterCore.ColliderTopology = .lineList)
  public var spheres: [AlterCore.ColliderSphereDefinition] {
    get
  }
  public var indices: [Swift.Int] {
    get
  }
  public var topology: AlterCore.ColliderTopology {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [AlterCore.ColliderSphereDefinition]
  public func component2() -> [Swift.Int]
  public func component3() -> AlterCore.ColliderTopology
  public func doCopy(_ spheres: [AlterCore.ColliderSphereDefinition], _ indices: [Swift.Int], _ topology: AlterCore.ColliderTopology = .lineList) -> AlterCore.ColliderDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.ColliderDefinition
  public static func == (lhs: AlterCore.ColliderDefinition, rhs: AlterCore.ColliderDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RandomValueDefinition : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ lowerBound: Swift.Float? = nil, _ upperBound: Swift.Float? = nil, _ mode: Swift.Float? = nil, _ kurtosis: Swift.Float? = nil, _ rareShare: Swift.Float = Float(0.1), _ modeIsMedian: Swift.Bool = false)
  public var lowerBound: Swift.Float? {
    get
  }
  public var upperBound: Swift.Float? {
    get
  }
  public var mode: Swift.Float? {
    get
  }
  public var kurtosis: Swift.Float? {
    get
  }
  public var rareShare: Swift.Float {
    get
  }
  public var modeIsMedian: Swift.Bool {
    get
  }
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.RandomValueDefinition
  public static func == (lhs: AlterCore.RandomValueDefinition, rhs: AlterCore.RandomValueDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TransformDefinition : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ translation: [Swift.Float]? = nil, _ rotation: [Swift.Float]? = nil, _ scale: [Swift.Float]? = nil)
  public var translation: [Swift.Float]? {
    get
  }
  public var rotation: [Swift.Float]? {
    get
  }
  public var scale: [Swift.Float]? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func component1() -> [Swift.Float]?
  public func component2() -> [Swift.Float]?
  public func component3() -> [Swift.Float]?
  public func doCopy(_ translation: [Swift.Float]? = nil, _ rotation: [Swift.Float]? = nil, _ scale: [Swift.Float]? = nil) -> AlterCore.TransformDefinition
  public static func serializer<TKotlinx_serialization_coreKSerializer>() -> TKotlinx_serialization_coreKSerializer where TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == AlterCore.TransformDefinition
  public static func == (lhs: AlterCore.TransformDefinition, rhs: AlterCore.TransformDefinition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedAvatarMatrix : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var sources: Swift.Set<AlterCore.Path> {
    get
  }
  public var matrix: AlterCore.AvatarMatrix {
    get
  }
  public static func == (lhs: AlterCore.LoadedAvatarMatrix, rhs: AlterCore.LoadedAvatarMatrix) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedDebugAnimationFrame : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ position: AlterCore.Vec3, _ rotation: AlterCore.Quaternion, _ scale: AlterCore.Vec3, _ blendshapes: [Swift.String : Swift.Float])
  public var position: AlterCore.Vec3 {
    get
  }
  public var rotation: AlterCore.Quaternion {
    get
  }
  public var scale: AlterCore.Vec3 {
    get
  }
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public static func == (lhs: AlterCore.LoadedDebugAnimationFrame, rhs: AlterCore.LoadedDebugAnimationFrame) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LoadedDebugAnimation : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var length: Swift.Float {
    get
  }
  public func frameAt(_ sceneTime: Swift.Float) -> AlterCore.LoadedDebugAnimationFrame
  public static func fromJson(_ data: Swift.String) -> AlterCore.Try<AlterCore.LoadedDebugAnimation>
  public static func == (lhs: AlterCore.LoadedDebugAnimation, rhs: AlterCore.LoadedDebugAnimation) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DebugMemoryTag : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ extraName: Swift.String?)
  public static func == (lhs: AlterCore.DebugMemoryTag, rhs: AlterCore.DebugMemoryTag) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Timer : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var elapsed: Swift.Double {
    get
  }
  public func tick() -> AlterCore.Timer
  public static func start() -> AlterCore.Timer
  public static func == (lhs: AlterCore.Timer, rhs: AlterCore.Timer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FPS : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ interval: Swift.Double)
  @discardableResult
  public func tick(_ consumer: ((Swift.Double) -> Swift.Void)?) -> Swift.Double
  public static func == (lhs: AlterCore.FPS, rhs: AlterCore.FPS) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TickerMapper {
  associatedtype T
  func invoke(_ value: Self.T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> Self.T
}
@_hasMissingDesignatedInitializers public class TickerMapperWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.TickerMapper {
  public typealias T = T
  public var _wrappedTickerMapper: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func invoke(_ value: T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> T
}
@_hasMissingDesignatedInitializers public class Ticker : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ interval: Swift.Double)
  public func tick<T, TTickerMapper>(_ value: T, _ mapper: TTickerMapper) -> T where T == TTickerMapper.T, TTickerMapper : AlterCore.TickerMapper
  public func tick<T>(_ value: T, _ mapper_: @escaping (T) -> T) -> T
  public static func == (lhs: AlterCore.Ticker, rhs: AlterCore.Ticker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinArray<T> : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> T)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> T
  public func iterator<TKotlinIterator>() -> TKotlinIterator where T == TKotlinIterator.T, TKotlinIterator : AlterCore.KotlinIterator
  public func set(_ index: Swift.Int, _ value: T)
  public func flatten() -> AlterCore.KotlinFloatArray where T : AlterCore.KotlinFloatArray
  public static func == (lhs: AlterCore.KotlinArray<T>, rhs: AlterCore.KotlinArray<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinFloatArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Float)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Float
  public func iterator() -> AlterCore.KotlinFloatIterator
  public func set(_ index: Swift.Int, _ value: Swift.Float)
  public static func == (lhs: AlterCore.KotlinFloatArray, rhs: AlterCore.KotlinFloatArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int
  public func iterator() -> AlterCore.KotlinIntIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int)
  public static func == (lhs: AlterCore.KotlinIntArray, rhs: AlterCore.KotlinIntArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinPair<A, B> : AlterCore.ConvertibleToKotlin, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ first: A, _ second: B)
  public var first: A {
    get
  }
  public var second: B {
    get
  }
  public func component1() -> A
  public func component2() -> B
  public func doCopy(_ first: A, _ second: B) -> AlterCore.KotlinPair<A, B>
  public func equals(_ other: Any?) -> Swift.Bool
  public func hashCode() -> Swift.Int
  public func toString() -> Swift.String
  public static func == (lhs: AlterCore.KotlinPair<A, B>, rhs: AlterCore.KotlinPair<A, B>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinThrowable : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ message: Swift.String?)
  public convenience init(_ cause: AlterCore.KotlinThrowable?)
  public convenience init()
  public convenience init(_ message: Swift.String?, _ cause: AlterCore.KotlinThrowable?)
  public var cause: AlterCore.KotlinThrowable? {
    get
  }
  public var message: Swift.String? {
    get
  }
  public func getStackTrace() -> AlterCore.KotlinArray<Swift.String>
  public func printStackTrace()
  public static func == (lhs: AlterCore.KotlinThrowable, rhs: AlterCore.KotlinThrowable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinException : AlterCore.KotlinThrowable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public convenience init(_ message: Swift.String?)
  public convenience init(_ message: Swift.String?, _ cause: AlterCore.KotlinThrowable?)
  public convenience init(_ cause: AlterCore.KotlinThrowable?)
  public static func == (lhs: AlterCore.KotlinException, rhs: AlterCore.KotlinException) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
}
@_hasMissingDesignatedInitializers public class KotlinByteArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.CChar)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func iterator() -> AlterCore.KotlinByteIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public static func == (lhs: AlterCore.KotlinByteArray, rhs: AlterCore.KotlinByteArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreDeserializationStrategy {
  associatedtype T
  var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor { get }
  func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> Self.T
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreDeserializationStrategyWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreDeserializationStrategy {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreDeserializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> T
}
public typealias DeserializationStrategyWrapper = AlterCore.Kotlinx_serialization_coreDeserializationStrategyWrapper
public typealias DeserializationStrategy = AlterCore.Kotlinx_serialization_coreDeserializationStrategy
public protocol Kotlinx_serialization_coreSerialFormat {
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialFormatWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerialFormat {
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
}
public typealias SerialFormatWrapper = AlterCore.Kotlinx_serialization_coreSerialFormatWrapper
public typealias SerialFormat = AlterCore.Kotlinx_serialization_coreSerialFormat
public protocol Kotlinx_serialization_coreStringFormat : AlterCore.Kotlinx_serialization_coreSerialFormat {
  func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreStringFormatWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreStringFormat {
  public var _wrappedKotlinx_serialization_coreStringFormat: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
}
public typealias StringFormatWrapper = AlterCore.Kotlinx_serialization_coreStringFormatWrapper
public typealias StringFormat = AlterCore.Kotlinx_serialization_coreStringFormat
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJson : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.Kotlinx_serialization_coreStringFormat {
  public var _wrappedKotlinx_serialization_coreStringFormat: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerialFormat: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ configuration: AlterCore.Kotlinx_serialization_jsonJsonConfiguration, _ serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule)
  public var configuration: AlterCore.Kotlinx_serialization_jsonJsonConfiguration {
    get
  }
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeFromJsonElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ element: AlterCore.Kotlinx_serialization_jsonJsonElement) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeFromString<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ string: Swift.String) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func encodeToJsonElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> AlterCore.Kotlinx_serialization_jsonJsonElement where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeToString<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) -> Swift.String where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func parseToJsonElement(_ string: Swift.String) -> AlterCore.Kotlinx_serialization_jsonJsonElement
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJson, rhs: AlterCore.Kotlinx_serialization_jsonJson) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias Json = AlterCore.Kotlinx_serialization_jsonJson
public protocol Kotlinx_serialization_coreSerializationStrategy {
  associatedtype T
  var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor { get }
  func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: Self.T)
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializationStrategyWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerializationStrategy {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreSerializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: T)
}
public typealias SerializationStrategyWrapper = AlterCore.Kotlinx_serialization_coreSerializationStrategyWrapper
public typealias SerializationStrategy = AlterCore.Kotlinx_serialization_coreSerializationStrategy
public protocol Kotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, AlterCore.Kotlinx_serialization_coreSerializationStrategy {
  associatedtype T
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreKSerializerWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreKSerializer {
  public typealias T = T
  public var _wrappedKotlinx_serialization_coreKSerializer: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreSerializationStrategy: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinx_serialization_coreDeserializationStrategy: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor {
    get
  }
  public func serialize(_ encoder: AlterCore.Kotlinx_serialization_coreEncoder, _ value: T)
  public func deserialize(_ decoder: AlterCore.Kotlinx_serialization_coreDecoder) -> T
}
public typealias KSerializerWrapper = AlterCore.Kotlinx_serialization_coreKSerializerWrapper
public typealias KSerializer = AlterCore.Kotlinx_serialization_coreKSerializer
public protocol KotlinIterator {
  associatedtype T
  func hasNext() -> Swift.Bool
  func next() -> Self.T
}
@_hasMissingDesignatedInitializers public class KotlinIteratorWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinIterator {
  public typealias T = T
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func hasNext() -> Swift.Bool
  public func next() -> T
}
@_hasMissingDesignatedInitializers public class KotlinIntProgression : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var first: Swift.Int {
    get
  }
  public var last: Swift.Int {
    get
  }
  public var step: Swift.Int {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func isEmpty() -> Swift.Bool
  public func iterator() -> AlterCore.KotlinIntIterator
  public static func == (lhs: AlterCore.KotlinIntProgression, rhs: AlterCore.KotlinIntProgression) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KotlinClosedRange {
  associatedtype T : AlterCore.KotlinComparable
  var endInclusive: Self.T { get }
  var start: Self.T { get }
  func contains(_ value: Self.T) -> Swift.Bool
  func isEmpty() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinClosedRangeWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinClosedRange where T : AlterCore.KotlinComparable {
  public typealias T = T
  public var _wrappedKotlinClosedRange: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var endInclusive: T {
    get
  }
  public var start: T {
    get
  }
  public func contains(_ value: T) -> Swift.Bool
  public func isEmpty() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinIntRange : AlterCore.KotlinIntProgression, AlterCore.KotlinClosedRange {
  public typealias T = Swift.Int
  public var _wrappedKotlinClosedRange: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ start: Swift.Int, _ endInclusive: Swift.Int)
  public var endInclusive: Swift.Int {
    get
  }
  public var start: Swift.Int {
    get
  }
  public func contains(_ value: AlterCore.KotlinIntRange.T) -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinIntRange, rhs: AlterCore.KotlinIntRange) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  override public var description: Swift.String {
    get
  }
  override public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinDoubleArray : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init(_ size: Swift.Int)
  public convenience init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Double)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Double
  public func iterator() -> AlterCore.KotlinDoubleIterator
  public func set(_ index: Swift.Int, _ value: Swift.Double)
  public static func == (lhs: AlterCore.KotlinDoubleArray, rhs: AlterCore.KotlinDoubleArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinFloatIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Float
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func next() -> AlterCore.KotlinFloatIterator.T
  public func nextFloat() -> Swift.Float
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinFloatIterator, rhs: AlterCore.KotlinFloatIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Int
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func next() -> AlterCore.KotlinIntIterator.T
  public func nextInt() -> Swift.Int
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinIntIterator, rhs: AlterCore.KotlinIntIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinByteIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.CChar
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func next() -> AlterCore.KotlinByteIterator.T
  public func nextByte() -> Swift.Int8
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinByteIterator, rhs: AlterCore.KotlinByteIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreDecoder {
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeDecoder
  func decodeBoolean() -> Swift.Bool
  func decodeByte() -> Swift.Int8
  func decodeChar() -> Foundation.unichar
  func decodeDouble() -> Swift.Double
  func decodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeFloat() -> Swift.Float
  func decodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreDecoder
  func decodeInt() -> Swift.Int
  func decodeLong() -> Swift.Int64
  func decodeNotNullMark() -> Swift.Bool
  func decodeNull() -> Swift.Never?
  func decodeNullableSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  func decodeSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func decodeShort() -> Swift.Int16
  func decodeString() -> Swift.String
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreDecoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreDecoder {
  public var _wrappedKotlinx_serialization_coreDecoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeDecoder
  public func decodeBoolean() -> Swift.Bool
  public func decodeByte() -> Swift.Int8
  public func decodeChar() -> Foundation.unichar
  public func decodeDouble() -> Swift.Double
  public func decodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeFloat() -> Swift.Float
  public func decodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreDecoder
  public func decodeInt() -> Swift.Int
  public func decodeLong() -> Swift.Int64
  public func decodeNotNullMark() -> Swift.Bool
  public func decodeNull() -> Swift.Never?
  public func decodeNullableSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  public func decodeSerializableValue<T, TKotlinx_serialization_coreDeserializationStrategy>(_ deserializer: TKotlinx_serialization_coreDeserializationStrategy) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeShort() -> Swift.Int16
  public func decodeString() -> Swift.String
}
public typealias DecoderWrapper = AlterCore.Kotlinx_serialization_coreDecoderWrapper
public typealias Decoder = AlterCore.Kotlinx_serialization_coreDecoder
public protocol Kotlinx_serialization_coreSerialDescriptor {
  var annotations: [AlterCore.KotlinAnnotation] { get }
  var elementsCount: Swift.Int { get }
  var isInline: Swift.Bool { get }
  var isNullable: Swift.Bool { get }
  var kind: AlterCore.Kotlinx_serialization_coreSerialKind { get }
  var serialName: Swift.String { get }
  func getElementAnnotations(_ index: Swift.Int) -> [AlterCore.KotlinAnnotation]
  func getElementDescriptor(_ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreSerialDescriptor
  func getElementIndex(_ name: Swift.String) -> Swift.Int
  func getElementName(_ index: Swift.Int) -> Swift.String
  func isElementOptional(_ index: Swift.Int) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialDescriptorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerialDescriptor {
  public var _wrappedKotlinx_serialization_coreSerialDescriptor: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var annotations: [AlterCore.KotlinAnnotation] {
    get
  }
  public var elementsCount: Swift.Int {
    get
  }
  public var isInline: Swift.Bool {
    get
  }
  public var isNullable: Swift.Bool {
    get
  }
  public var kind: AlterCore.Kotlinx_serialization_coreSerialKind {
    get
  }
  public var serialName: Swift.String {
    get
  }
  public func getElementAnnotations(_ index: Swift.Int) -> [AlterCore.KotlinAnnotation]
  public func getElementDescriptor(_ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreSerialDescriptor
  public func getElementIndex(_ name: Swift.String) -> Swift.Int
  public func getElementName(_ index: Swift.Int) -> Swift.String
  public func isElementOptional(_ index: Swift.Int) -> Swift.Bool
}
public typealias SerialDescriptorWrapper = AlterCore.Kotlinx_serialization_coreSerialDescriptorWrapper
public typealias SerialDescriptor = AlterCore.Kotlinx_serialization_coreSerialDescriptor
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializersModule : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func dumpTo(_ collector: AlterCore.Kotlinx_serialization_coreSerializersModuleCollector)
  public func getContextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ typeArgumentsSerializers: [TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public func getPolymorphic<T, TKotlinKClass, TKotlinx_serialization_coreSerializationStrategy>(_ baseClass: TKotlinKClass, _ value: T) -> TKotlinx_serialization_coreSerializationStrategy? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreSerializationStrategy.T
  public func getPolymorphic<T, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ serializedClassName: Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy? where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
  public static func == (lhs: AlterCore.Kotlinx_serialization_coreSerializersModule, rhs: AlterCore.Kotlinx_serialization_coreSerializersModule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SerializersModule = AlterCore.Kotlinx_serialization_coreSerializersModule
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJsonConfiguration : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var allowSpecialFloatingPointValues: Swift.Bool {
    get
  }
  public var allowStructuredMapKeys: Swift.Bool {
    get
  }
  public var classDiscriminator: Swift.String {
    get
  }
  public var coerceInputValues: Swift.Bool {
    get
  }
  public var encodeDefaults: Swift.Bool {
    get
  }
  public var explicitNulls: Swift.Bool {
    get
  }
  public var ignoreUnknownKeys: Swift.Bool {
    get
  }
  public var isLenient: Swift.Bool {
    get
  }
  public var prettyPrint: Swift.Bool {
    get
  }
  public var prettyPrintIndent: Swift.String {
    get
  }
  public var useAlternativeNames: Swift.Bool {
    get
  }
  public var useArrayPolymorphism: Swift.Bool {
    get
  }
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJsonConfiguration, rhs: AlterCore.Kotlinx_serialization_jsonJsonConfiguration) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias JsonConfiguration = AlterCore.Kotlinx_serialization_jsonJsonConfiguration
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_jsonJsonElement : AlterCore.ConvertibleToKotlin, Swift.Hashable {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public static func == (lhs: AlterCore.Kotlinx_serialization_jsonJsonElement, rhs: AlterCore.Kotlinx_serialization_jsonJsonElement) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public typealias JsonElement = AlterCore.Kotlinx_serialization_jsonJsonElement
public protocol Kotlinx_serialization_coreEncoder {
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func beginCollection(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ collectionSize: Swift.Int) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  func encodeBoolean(_ value: Swift.Bool)
  func encodeByte(_ value: Swift.Int8)
  func encodeChar(_ value: Foundation.unichar)
  func encodeDouble(_ value: Swift.Double)
  func encodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int)
  func encodeFloat(_ value: Swift.Float)
  func encodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreEncoder
  func encodeInt(_ value: Swift.Int)
  func encodeLong(_ value: Swift.Int64)
  func encodeNotNullMark()
  func encodeNull()
  func encodeNullableSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeShort(_ value: Swift.Int16)
  func encodeString(_ value: Swift.String)
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreEncoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreEncoder {
  public var _wrappedKotlinx_serialization_coreEncoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func beginCollection(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ collectionSize: Swift.Int) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  public func beginStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreCompositeEncoder
  public func encodeBoolean(_ value: Swift.Bool)
  public func encodeByte(_ value: Swift.Int8)
  public func encodeChar(_ value: Foundation.unichar)
  public func encodeDouble(_ value: Swift.Double)
  public func encodeEnum(_ enumDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int)
  public func encodeFloat(_ value: Swift.Float)
  public func encodeInline(_ inlineDescriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> AlterCore.Kotlinx_serialization_coreEncoder
  public func encodeInt(_ value: Swift.Int)
  public func encodeLong(_ value: Swift.Int64)
  public func encodeNotNullMark()
  public func encodeNull()
  public func encodeNullableSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeSerializableValue<T, TKotlinx_serialization_coreSerializationStrategy>(_ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeShort(_ value: Swift.Int16)
  public func encodeString(_ value: Swift.String)
}
public typealias EncoderWrapper = AlterCore.Kotlinx_serialization_coreEncoderWrapper
public typealias Encoder = AlterCore.Kotlinx_serialization_coreEncoder
@_hasMissingDesignatedInitializers public class KotlinDoubleIterator : AlterCore.ConvertibleToKotlin, Swift.Hashable, AlterCore.KotlinIterator {
  public typealias T = Swift.Double
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func next() -> AlterCore.KotlinDoubleIterator.T
  public func nextDouble() -> Swift.Double
  public func hasNext() -> Swift.Bool
  public static func == (lhs: AlterCore.KotlinDoubleIterator, rhs: AlterCore.KotlinDoubleIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Kotlinx_serialization_coreCompositeDecoder {
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func decodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
  func decodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int8
  func decodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Foundation.unichar
  func decodeCollectionSize(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Double
  func decodeElementIndex(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  func decodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Float
  func decodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreDecoder
  func decodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int
  func decodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int64
  func decodeNullableSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  func decodeSequentially() -> Swift.Bool
  func decodeSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  func decodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int16
  func decodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.String
  func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreCompositeDecoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreCompositeDecoder {
  public var _wrappedKotlinx_serialization_coreCompositeDecoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func decodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
  public func decodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int8
  public func decodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Foundation.unichar
  public func decodeCollectionSize(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Double
  public func decodeElementIndex(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor) -> Swift.Int
  public func decodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Float
  public func decodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreDecoder
  public func decodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int
  public func decodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int64
  public func decodeNullableSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T? where TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinx_serialization_coreDeserializationStrategy.T == T?
  public func decodeSequentially() -> Swift.Bool
  public func decodeSerializableElement<T, TKotlinx_serialization_coreDeserializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ deserializer: TKotlinx_serialization_coreDeserializationStrategy, _ previousValue: T?) -> T where T == TKotlinx_serialization_coreDeserializationStrategy.T, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy
  public func decodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Int16
  public func decodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.String
  public func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
}
public typealias CompositeDecoderWrapper = AlterCore.Kotlinx_serialization_coreCompositeDecoderWrapper
public typealias CompositeDecoder = AlterCore.Kotlinx_serialization_coreCompositeDecoder
public protocol KotlinAnnotation {
}
@_hasMissingDesignatedInitializers public class KotlinAnnotationWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinAnnotation {
  public var _wrappedKotlinAnnotation: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerialKind : AlterCore.ConvertibleToKotlin, Swift.Hashable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public convenience init()
  public func hash() -> Swift.UInt
  public static func == (lhs: AlterCore.Kotlinx_serialization_coreSerialKind, rhs: AlterCore.Kotlinx_serialization_coreSerialKind) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias SerialKind = AlterCore.Kotlinx_serialization_coreSerialKind
public protocol Kotlinx_serialization_coreSerializersModuleCollector {
  func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ provider: @escaping ([TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ serializer: TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinKClass.T == TKotlinx_serialization_coreKSerializer.T
  func polymorphic<Base, Sub, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ baseClass: TKotlinKClass, _ actualClass: TKotlinKClass, _ actualSerializer: TKotlinx_serialization_coreKSerializer) where Base == TKotlinKClass.T, Sub == TKotlinx_serialization_coreKSerializer.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  func polymorphicDefault<Base, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ defaultSerializerProvider: @escaping (Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy?) where Base == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreSerializersModuleCollectorWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreSerializersModuleCollector {
  public var _wrappedKotlinx_serialization_coreSerializersModuleCollector: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ provider: @escaping ([TKotlinx_serialization_coreKSerializer]) -> TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinx_serialization_coreKSerializer.T == Any?
  public func contextual<T, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ kClass: TKotlinKClass, _ serializer: TKotlinx_serialization_coreKSerializer) where T == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer, TKotlinKClass.T == TKotlinx_serialization_coreKSerializer.T
  public func polymorphic<Base, Sub, TKotlinKClass, TKotlinx_serialization_coreKSerializer>(_ baseClass: TKotlinKClass, _ actualClass: TKotlinKClass, _ actualSerializer: TKotlinx_serialization_coreKSerializer) where Base == TKotlinKClass.T, Sub == TKotlinx_serialization_coreKSerializer.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreKSerializer : AlterCore.Kotlinx_serialization_coreKSerializer
  public func polymorphicDefault<Base, TKotlinKClass, TKotlinx_serialization_coreDeserializationStrategy>(_ baseClass: TKotlinKClass, _ defaultSerializerProvider: @escaping (Swift.String?) -> TKotlinx_serialization_coreDeserializationStrategy?) where Base == TKotlinKClass.T, TKotlinKClass : AlterCore.KotlinKClass, TKotlinx_serialization_coreDeserializationStrategy : AlterCore.Kotlinx_serialization_coreDeserializationStrategy, TKotlinKClass.T == TKotlinx_serialization_coreDeserializationStrategy.T
}
public typealias SerializersModuleCollectorWrapper = AlterCore.Kotlinx_serialization_coreSerializersModuleCollectorWrapper
public typealias SerializersModuleCollector = AlterCore.Kotlinx_serialization_coreSerializersModuleCollector
public protocol KotlinKDeclarationContainer {
}
@_hasMissingDesignatedInitializers public class KotlinKDeclarationContainerWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKDeclarationContainer {
  public var _wrappedKotlinKDeclarationContainer: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKAnnotatedElement {
}
@_hasMissingDesignatedInitializers public class KotlinKAnnotatedElementWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKAnnotatedElement {
  public var _wrappedKotlinKAnnotatedElement: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKClassifier {
}
@_hasMissingDesignatedInitializers public class KotlinKClassifierWrapper : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKClassifier {
  public var _wrappedKotlinKClassifier: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
}
public protocol KotlinKClass : AlterCore.KotlinKAnnotatedElement, AlterCore.KotlinKClassifier, AlterCore.KotlinKDeclarationContainer {
  associatedtype T
  var qualifiedName: Swift.String? { get }
  var simpleName: Swift.String? { get }
  func isInstance(_ value: Any?) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinKClassWrapper<T> : AlterCore.ConvertibleToKotlin, AlterCore.KotlinKClass {
  public typealias T = T
  public var _wrappedKotlinKClass: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKDeclarationContainer: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKAnnotatedElement: Swift.AnyObject {
    get
  }
  public var _wrappedKotlinKClassifier: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var qualifiedName: Swift.String? {
    get
  }
  public var simpleName: Swift.String? {
    get
  }
  public func isInstance(_ value: Any?) -> Swift.Bool
}
public protocol Kotlinx_serialization_coreCompositeEncoder {
  var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule { get }
  func encodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Bool)
  func encodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int8)
  func encodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Foundation.unichar)
  func encodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Double)
  func encodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Float)
  func encodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreEncoder
  func encodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int)
  func encodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int64)
  func encodeNullableSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  func encodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int16)
  func encodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.String)
  func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
  func shouldEncodeElementDefault(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class Kotlinx_serialization_coreCompositeEncoderWrapper : AlterCore.ConvertibleToKotlin, AlterCore.Kotlinx_serialization_coreCompositeEncoder {
  public var _wrappedKotlinx_serialization_coreCompositeEncoder: Swift.AnyObject {
    get
  }
  required public convenience init(_ wrapped: AlterCore.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  @objc deinit
  public var serializersModule: AlterCore.Kotlinx_serialization_coreSerializersModule {
    get
  }
  public func encodeBooleanElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Bool)
  public func encodeByteElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int8)
  public func encodeCharElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Foundation.unichar)
  public func encodeDoubleElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Double)
  public func encodeFloatElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Float)
  public func encodeInlineElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> AlterCore.Kotlinx_serialization_coreEncoder
  public func encodeIntElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int)
  public func encodeLongElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int64)
  public func encodeNullableSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T?) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeSerializableElement<T, TKotlinx_serialization_coreSerializationStrategy>(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ serializer: TKotlinx_serialization_coreSerializationStrategy, _ value: T) where T == TKotlinx_serialization_coreSerializationStrategy.T, TKotlinx_serialization_coreSerializationStrategy : AlterCore.Kotlinx_serialization_coreSerializationStrategy
  public func encodeShortElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.Int16)
  public func encodeStringElement(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int, _ value: Swift.String)
  public func endStructure(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor)
  public func shouldEncodeElementDefault(_ descriptor: AlterCore.Kotlinx_serialization_coreSerialDescriptor, _ index: Swift.Int) -> Swift.Bool
}
public typealias CompositeEncoderWrapper = AlterCore.Kotlinx_serialization_coreCompositeEncoderWrapper
public typealias CompositeEncoder = AlterCore.Kotlinx_serialization_coreCompositeEncoder
extension AlterCore.FaceTracker {
  public static func createVideoTracker() -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public static func createImageTracker() -> AlterCore.Future<AlterCore.Try<AlterCore.FaceTracker>>
  public func track(_ image: CoreVideo.CVPixelBuffer?) -> AlterCore.FaceTrackerResult?
  public func track(_ image: CoreMedia.CMSampleBuffer?) -> AlterCore.FaceTrackerResult?
  public func track(_ image: UIKit.UIImage?) -> AlterCore.FaceTrackerResult?
}
extension AlterCore.TrackerImage {
  public convenience init?(_ sampleBuffer: CoreMedia.CMSampleBuffer)
}
public class RecordedVideo {
  final public let filePath: Foundation.URL
  public init(_ path: Foundation.URL)
  public func saveToPhotos() -> AlterCore.Future<AlterCore.Try<Swift.String>>
  public func deleteVideo()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class BaseVideoRecorder : ObjectiveC.NSObject, AVFoundation.AVCaptureAudioDataOutputSampleBufferDelegate {
  public func startRecording() -> AlterCore.Try<Swift.Void>
  public func stopRecording() -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  public func stopRecording(after: Dispatch.DispatchTimeInterval) -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  @objc public func captureOutput(_ output: AVFoundation.AVCaptureOutput, didOutput sampleBuffer: CoreMedia.CMSampleBuffer, from connection: AVFoundation.AVCaptureConnection)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers public class VideoRecorder : AlterCore.BaseVideoRecorder {
  override public func startRecording() -> AlterCore.Try<Swift.Void>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class ViewRecorder : AlterCore.BaseVideoRecorder {
  override public func startRecording() -> AlterCore.Try<Swift.Void>
  override public func stopRecording() -> AlterCore.Future<AlterCore.Try<AlterCore.RecordedVideo>>
  @objc deinit
}
extension AlterCore.AvatarRenderer {
  public func startVideoRecording(_ resolution: (Swift.Int, Swift.Int), _ recordSound: Swift.Bool = false, _ desiredFps: Swift.Int = 30) -> AlterCore.Try<AlterCore.VideoRecorder>
}
extension AlterCore.FaceTrackerResult : Swift.Hashable {}
extension AlterCore.FaceTrackerWithResult : Swift.Hashable {}
extension AlterCore.FaceTrackerReprojectorResult : Swift.Hashable {}
extension AlterCore.Path : Swift.Hashable {}
extension AlterCore.ThumbnailConfigDefinition : Swift.Hashable {}
extension AlterCore.AvatarPresetDefinition : Swift.Hashable {}
extension AlterCore.ItemSelectionDefinition : Swift.Hashable {}
extension AlterCore.SelectionsDefinition : Swift.Hashable {}
extension AlterCore.SectionItemReferenceDefinition : Swift.Hashable {}
extension AlterCore.SectionConfigurationDefinition : Swift.Hashable {}
extension AlterCore.SectionNodeDefinition : Swift.Hashable {}
extension AlterCore.DesignerConfigurationDefinition : Swift.Hashable {}
extension AlterCore.DesignerLogicSectionNodeDefinition : Swift.Hashable {}
extension AlterCore.DesignerLogicSectionRuleDefinition : Swift.Hashable {}
extension AlterCore.DesignerLogicSectionConfigurationDefinition : Swift.Hashable {}
extension AlterCore.DesignerLogicConfigurationDefinition : Swift.Hashable {}
extension AlterCore.DesignerLogicLocaleDefinition : Swift.Hashable {}
extension AlterCore.MaterialPickerMetadataDefinition : Swift.Hashable {}
extension AlterCore.MaterialPickerVariantMetadataDefinition : Swift.Hashable {}
extension AlterCore.ColorPickerMetadataDefinition : Swift.Hashable {}
extension AlterCore.ItemVariantMetadataDefinition : Swift.Hashable {}
extension AlterCore.ItemMetadataDefinition : Swift.Hashable {}
extension AlterCore.LocaleDefinition : Swift.Hashable {}
extension AlterCore.AvatarAnimationData : Swift.Hashable {}
extension AlterCore.AvatarMatrix : Swift.Hashable {}
extension AlterCore.BlendshapeBoneConversionDefinition : Swift.Hashable {}
extension AlterCore.BoneAdjustmentDefinition : Swift.Hashable {}
extension AlterCore.BlendingTransformsDefinition : Swift.Hashable {}
extension AlterCore.BoneBlenderDefinition : Swift.Hashable {}
extension AlterCore.ComputationDefinition : Swift.Hashable {}
extension AlterCore.ContainerDefinition : Swift.Hashable {}
extension AlterCore.ItemDefinition : Swift.Hashable {}
extension AlterCore.ItemLocaleDefinition : Swift.Hashable {}
extension AlterCore.ItemPartDefinition : Swift.Hashable {}
extension AlterCore.ItemReferenceDefinition : Swift.Hashable {}
extension AlterCore.MaterialProperty : Swift.Hashable {}
extension AlterCore.MaterialDefinition : Swift.Hashable {}
extension AlterCore.MaterialLayerDefinition : Swift.Hashable {}
extension AlterCore.MaterialLayerProperty : Swift.Hashable {}
extension AlterCore.MaterialLibraryDefinition : Swift.Hashable {}
extension AlterCore.MaterialVariantsDefinition : Swift.Hashable {}
extension AlterCore.ModelDefinition : Swift.Hashable {}
extension AlterCore.PhysicsDefinition : Swift.Hashable {}
extension AlterCore.ColliderSphereDefinition : Swift.Hashable {}
extension AlterCore.ColliderDefinition : Swift.Hashable {}
extension AlterCore.TransformDefinition : Swift.Hashable {}
extension AlterCore.KotlinPair : Swift.Hashable {}